\documentclass[11pt,a4paper]{article}

\usepackage{times}
\usepackage{epsfig}
\usepackage{latexsym}
\usepackage{amsmath,amscd,amssymb}
\usepackage{url}
\usepackage{graphicx}
\usepackage{xspace}
\usepackage{a4wide}

\usepackage{paralist}
\usepackage{enumerate}

\def\tuple#1{\langle#1\rangle}
\newcommand{\M}{}
\def\brave{\models_b\,}
\def\cautious{\models_c\,}
\newcommand{\mm}[1]{\ensuremath{\mathit{MMod}(#1)}}
\newcommand{\Mod}[1]{\ensuremath{\mathit{Mod}(#1)}}
\newcommand{\nmodels}{\not\models}

\def\lqm{\leq_m^P}

\newcommand{\co}{\mbox{\rm co-}}
\newcommand{\Pol}{\ensuremath{\protect\mathbf{P}}\xspace}
\newcommand{\LOG}{\ensuremath{\mathbf{LOG}}\xspace}
\newcommand{\NLOG}{\ensuremath{\mathbf{NLOG}}\xspace}
\newcommand{\DP}{\ensuremath{\mathbf{D}^p}\xspace}
\newcommand{\NP}{\ensuremath{\mathbf{NP}}\xspace}
\newcommand{\coNP}{\ensuremath{\protect\co\NP}\xspace}
\newcommand{\CONP}{\coNP}
\newcommand{\ThetaP}[1]{\ensuremath{\Theta^{\protect{P}}_{#1}}\xspace}
\newcommand{\SigmaP}[1]{\ensuremath{\Sigma^{\protect{P}}_{#1}}\xspace}
\newcommand{\PSigmaP}[1]{\ensuremath{\Pol^{\Sigma^{\protect{P}}_{#1}}}\xspace}
\newcommand{\DeltalogP}[1]{\ensuremath{\protect{\Delta}_{#1}^{{\protect{P}}}[O(\log
                        n)]}\xspace}
                        
\newcommand{\PNP}{\ensuremath{\Pol^{\NP}}\xspace}
\newcommand{\DeltaP}[1]{\ensuremath{\Delta^{\protect{P}}_{#1}}\xspace}
\newcommand{\PiP}[1]{\ensuremath{\Pi^{{P}}_{#1}}\xspace}
\newcommand{\FPol}{\ensuremath{\protect\mathbf{FP}}\xspace}
\newcommand{\FNP}{\ensuremath{\protect\mathbf{FNP}}\xspace}
\newcommand{\FCONP}{\ensuremath{\protect\co\FNP}\xspace}
\newcommand{\FSigmaP}[1]{\ensuremath{\protect\mathbf{F\Sigma}_{#1}^{{\protect{P}}}}\xspace}
\newcommand{\FPiP}[1]{\ensuremath{\protect\mathbf{F\Pi}_{#1}^{{\protect{P}}}}\xspace}
\newcommand{\FDeltaP}[1]{\ensuremath{\protect\mathbf{F}{\Delta}_{#1}^{{\protect{P}}}}\xspace}
\newcommand{\FDeltalogP}[1]{\ensuremath{\protect\mathbf{F}{\Delta}_{#1}^{{\protect{P}}}[O(\log n)]}\xspace}
\newcommand{\FPNP}{\ensuremath{\FPol^{\NP}}\xspace}
\newcommand{\FPNPpar}{\ensuremath{\FPol_\|^{\NP}}\xspace}
\newcommand{\PNPpar}{\ensuremath{\Pol_\|^{\NP}}\xspace}
\newcommand{\PNPpark}[1]{\ensuremath{\Pol_{\|[#1]}^{\NP}}\xspace}
\newcommand{\FPNPlogwit}{\ensuremath{\FPol^{\NP}[log, wit]}\xspace}

\newcommand{\FPSigmaP}[1]{\ensuremath{\FPol^{\protect\mathbf{\Sigma}_{#1}^{{\protect{P}}}}}\xspace}
\newcommand{\FPSigmaPpar}[1]{\ensuremath{\FPol_\|^{\protect\mathbf{\Sigma}_{#1}^{{\protect{P}}}}}\xspace}
\newcommand{\PSigmaPpar}[1]{\ensuremath{\Pol_\|^{\protect\mathbf{\Sigma}_{#1}^{{\protect{P}}}}}\\xspace}
\newcommand{\FNPloglong}{\ensuremath{\FNP\textrm{//OptP[$O(\log n)$]}}\xspace}
\newcommand{\FNPlog}{\ensuremath{\FNP\textrm{//$\log$}}\xspace}
\newcommand{\RPX}{\ensuremath{\protect\mathbf{RP}\cdot\FPol_\|^{\SigmaP{2}}}\xspace}
\newcommand{\PSPACE}{\ensuremath{\mathbf{PSPACE}}\xspace}
\newcommand{\NPSPACE}{\ensuremath{\mathbf{NPSPACE}}\xspace}
\newcommand{\EXPTIME}{\ensuremath{\mathbf{EXPTIME}}\xspace}
\newcommand{\NEXPTIME}{\ensuremath{\mathbf{NEXPTIME}}\xspace}

\newcommand{\ol}[1]{\overline{#1}}

\newcommand{\nop}[1]{}

\title{\vspace*{-2\baselineskip}Exercises for \\[0.2cm] 
`` Komplexit\"atsanalyse (Complexity Analysis)''\\[0.2cm]
2.0 VU 184.215, TU Vienna, SS 2019}


\date{v~3.0}

\begin{document}

%\maketitle

\begin{enumerate}
\item[CT.1]  (10) Examine whether the following restricted versions of SAT  are tractable.
  
  \begin{itemize}

  \item {\bf Not-All-Equal SAT, NAESAT}: The input formula $F$ is a
        CNF, and the question is whether $F$ can be satisfied 
        by some assignment $\sigma$ to the variables such that in no clause of $F$ 
        all literals are true.
        
        Example: $F = (x_1 \lor x_2 ) \land (x_2 \lor \neg x_3)$; take e.g. $\sigma(x_1)=1$, $\sigma(x_2)=0$, $\sigma(x_3)=0$.  \\
        
        
\item  {\bf Read-$2$ SAT}: The input formula $F$ is a CNF, and each
        variable occurs only at most $2$ times in $F$.
        

 \item {\bf All-Resolve-SAT}:  The input formula $F$ is a  CNF, and
 each pair of distinct clauses $c$ and $c'$ of $F$ resolves, i.e.,
 there is a variable $x$ such that $c = x \lor \alpha$ and $c' = \neg
 x\lor   \beta$ or the other way round ($c = \neg x \lor \alpha$ and
 $c' = x\lor \beta$)

 Examples:  $F=x\land \neg x$;  $G = (x \lor y) \land (\neg x \lor z)
 \land (\neg z \lor \neg y)$

\end{itemize}

Bonus: determine whether {\bf Read-$k$ SAT}, where $k>1$ is fixed, is
tractable, for each $k$.

\bigskip

\emph{Solution:}

  \begin{itemize}

  \item {\bf Not-All-Equal SAT, NAESAT}: The input formula $F$ is a
        CNF, and the question is whether $F$ can be satisfied 
        by some assignment $\sigma$ to the variables such that in no clause of $F$ 
        all literals are true.
        
        Example: $F = (x_1 \lor x_2 ) \land (x_2 \lor \neg x_3)$; take e.g. $\sigma(x_1)=1$, $\sigma(x_2)=0$, $\sigma(x_3)=0$.  \\
        
        
        
This problem is not-tractable, in fact it is \NP-hard. To support this claim a polynomial reduction from \textbf{CNF} to \textbf{NAESAT} will be given. Let $\varphi$ be a \textbf{CNF} instance, i.e. a formula in CNF. Consider the following translation.  

Let $t$ and $f$ be two new propositional variables, let $\varphi:= (p_{11} \lor \dots \lor p_{1n_1}) \land \dots  \land (p_{m1} \lor \dots \lor p_{mn_m})  $ be a formula in CNF with $p_{ij}$ being literals. Let $l_{i1} , \dots , l_{in_i}, l'_{i1} , \dots , l'_{in_i}$ be literals for $i \in \{1, \dots m\}$ and let $\tau$ be the following transformation

\begin{equation*}
\begin{split}
\tau(\varphi) := (t \lor f) \land  \bigwedge_{i =1}^{m}  (l'_{i1} \lor \dots \lor l'_{in_i} \lor t)  \land \bigwedge_{i =1}^{m}    (l_{i1} \lor \dots \lor l_{in_i}, \lor f) \\
\end{split}
\end{equation*}
such that $l_{ij}:=p_{ij}[x_k/y_k]$ and $l'_{ij}:=p_{ij}[x_k/y'_k]$, with $x_k \in Var(\varphi)$ and $y_k, y'_k$ being fresh and distinct new variables, i.e. $y_k, y'_k \in \mathit{Var}(\tau(\varphi))$.
That is, using $\varphi$ we simply build two copies $\varphi_t$ and $\varphi_f$ of $\varphi$ where each copy has its own set of variables and each clause in the prior is extended by the variable $t$ and each in the latter by $f$.


What remains to show is that $\chi_{\textbf{CNF}}(\varphi) = 1$ if and only if $\chi_{\textbf{NAESAT}}(\tau(\varphi)) = 1$. \\

"$\Rightarrow$:" Assume that $\chi_{\textbf{CNF}}(\varphi) = 1$, meaning that $\varphi$ is in CNF and has an satisfying assignment $\sigma$. Let $\sigma_{\tau}$ be the truth assignment for $\tau(\varphi)$, which shall be constructed based on the assignment $\sigma$. 
Firstly, $\varphi_f$ is merely a copy of $\varphi$, which clauses are extended by $f$. Hence, let $\sigma_{\tau}(y_k)=\sigma(x_k)$. Since, $\sigma$ is a satisfying assignment at least one literal in each clause is  satisfied. Moreover, let $\sigma_{\tau}(f)=0$, thus it follows that every clause in $\varphi_f$ has one literal that evaluates to $1$  and one that evaluates to $0$ under $\sigma_{\tau}$. Now, since $(t \lor f)$ and $\sigma_{\tau}(f)=0$ it follows that $\sigma_{\tau}(t)=1$. Hence, every clause in $\varphi_t$ is now satisfied, thus for all $y'_k$ let $\sigma_{\tau}(y'_k)=0$. Therefore, in each clause of $\varphi_t$ there exists one literal that evaluates to $1$ and one that evaluates to $0$.
A satisfying assignment of $\tau(\varphi)$ for the problem $\textbf{NAESAT}$ is found, and thus $\chi_{\textbf{CNF}}(\tau(\varphi)) = 1$.

"$\Leftarrow$": Assume that $\chi_{\textbf{CNF}}(\tau(\varphi)) = 1$, meaning that there exists an satisfying assignment $\sigma_{\tau}$ such that not all literals are true. That is, either $\sigma_{\tau}(t)=1$ or $\sigma_{\tau}(f)=1$. Without loss of generality assume the prior. 
Implying that  $\sigma_{\tau}(f)=0$. However, $\varphi_f$ is satisfied under $\sigma_{\tau}$, thus for each clause $C_i$ in $\varphi_f$ there must be a literal $l_ij \neq f$ that is satisfied under $\sigma_{\tau}$. Now, given the fact that $\varphi_f$ is a copy of $\varphi$ with every clause being extended by $f$ and the fact that $\sigma_{\tau}(f)=0$ it follows that $\sigma(x_k)=\sigma_{\tau}(y_k)$ is a satisfying assignment of $\varphi$. Resulting in $\chi_{\textbf{CNF}}(\varphi) = 1$.


Clearly, if this is the $\psi_f$ is satisfied, without assigning $f$ to true. Meaning that for $\psi_f$ there exists an assignment that satisfies every clause, which can only be the case if in each clause, there exists at least one literal that evaluates to true.

\bigskip
        
\item  {\bf Read-$2$ SAT}: The input formula $F$ is a CNF, and each
        variable occurs only at most $2$ times in $F$. \\

This variant is tractable. To show this statement, let $\varphi$ be a CNF-formula, where every variable occurs at most twice.
Now consider the following algorithm.
\texttt{
\begin{tabbing}
Read\=-2-SAT($\varphi$): \\
\> $\Gamma:= \mathit{Cl}(\varphi)$\\
\> wh\=ile $\Gamma \neq \emptyset$:\\
\>\> if \=$\exists C , C' \in \Gamma \; C=(x) \land C'=(\neg x)$: // (0) \\
\>\>\> return False \\
\>\> $\Gamma' := \emptyset$:\\
\>\> while $\Gamma \neq \Gamma'$:  //  (1)\\
\>\>\> $\Gamma := \Gamma'$\\
\>\>\> $\Gamma' :=$ remove\_tautological\_clauses($\Gamma $) // (1.1) \\
\>\>\>  $\Gamma' :=$ remove\_clauses\_with\_monotone\_variables($\Gamma'$)  // (1.2)\\
\>\> $C := $ choose\_random\_clause($\Gamma$)\\
\>\> for  $C' \in \Gamma$:  // (2)\\
\>\>\> if \= $C=(l \lor \alpha)$ and  $C'=(\overline{l} \lor \beta)$ // (2.1) \\
\>\>\>\> $C_n := (\alpha \lor \beta)$  // $\alpha$ or $\beta$ could be empty (not both -> (0)) \\
\>\>\>\> $\Gamma:= (\Gamma \setminus \{C, C'\}) \cup \{C_n\}$\\
\>\>\>\> break  // exit for-loop\\
\> return True\\
\end{tabbing}}

(0) If there are two complementary unit clauses, there can not be an assignment satisfying the formula.

(1.1) A variable is monotone if it only occurs either positively or negatively. Hence, one can safely satisfy the all clauses in which this variable occurs by simply choosing an assignment corresponding to the polarity of the occurrence, i.e. if $x$ is negative monotone then choose $\sigma$ such that $\sigma(x)=0$ and vice verse. This choice can not lead to another clause being no longer satisfiable, i.e. no satisfying assignment relies on the fact that the such a monotone literal is not satisfied. Hence, this step preserves satisfiability.

(1.2) A clause is tautological if it has the form $(x \lor \neg x \lor \alpha)$. Because any assignment satisfies this clause,they can be removed safely as well, i.e. removing this clause preserves satisfiability.

Hence, after (1) $\Gamma$ exhibits the following properties.   
\begin{itemize}
\item \emph{No clause occurs twice. }


If they would the variables within must be monotone and can contain a variable twice, thus those clauses were removed in step (1.1).

%\item \emph{Every clause contains two or more variables. }
%
%There can not be two complementary unit clauses, see step (0). Hence, all unit clauses are removed in (1.1).
%If they contain the same variable twice, then they must appear as complementary literals. Otherwise, they were removed in step (1.1). However, in that case this cause is tautological. Meaning it was removed in step (1.2).
%

\item\emph{ Every variable occurs once as positive literal and once as negative literal in two different clauses.}

Otherwise those variables are monotone and were removed in step (1.1) or they would be part of a tautological clause.
\end{itemize}
The whole step (1) can be done in polynomial time. Firstly, the number of iterations in the while loop is clearly bounded by the number of clauses in $\Gamma$, i.e. clauses are removed until it is no longer possible. Secondly, (1.1) runs in polynomial time as well, i.e. for each variable run through every clause, if it is present in said clause save the polarity of its occurrences and compare the two values for monotonicity. Thirdly, running through all clauses and checking if they contain complementary literals is also polynomial wrt. to the input.
Lastly,  with every step preserving satisfiability $\Gamma$ after (1) is satisfiable if and only if $\Gamma$ before (1) is satisfiable. \\


\emph{Observation 1: Let $C=(x \lor \alpha)$ and $C'=(\neg x \lor \beta)$ where $\alpha$ and $\beta$ are some disjunction of literals not containing $x$ or $\neg x$. Then $\{C,C'\}$ is satisfiable if and only if $\{(\alpha \lor \beta)\}$ is satisfiable.}

$"\Rightarrow"$: $\{C,C'\}$ is satisfiable. Therefore, either $\alpha$ or $\beta$ has to be satisfied, i.e. $x$ and $\neg x$ can not both be true. Hence, any assignment $\sigma$ satisfying $\{C,C'\}$ must also satisfy $\{(\alpha \lor \beta)\}$.
$"\Leftarrow"$:  $\{(\alpha \lor \beta)\}$ is satisfiable. Hence, for every assignment $\sigma$ either $\alpha$ or $\beta$ is satisfied. If $\alpha$ is satisfied under $\sigma$, then $C$ is satisfied, without relying on the truth assignment of $x$. Hence, $\sigma$ can be extended by the assignment $\{x \mapsto 0\}$ in order to satisfy $C'$. Analogue for the other case. \\

As for step (2). Choosing a clause $C=(l \lor \alpha)$ at random, due to (0) and (1) one knows that there must be a clause $C'=(\overline{l} \lor \beta)$, different from $C$ in $\Gamma$ containing the complement of the literal $l$, i.e. $\overline{l}$. W.l.o.g. let $l=x$. After the respective clause is found, the next step (2.1) is basically a resolution step. From Observation 1 it follows that $\Gamma$ is satisfiable if and only if $(\Gamma \setminus \{C, C'\}) \cup \{(\alpha \lor \beta)\}$ is satisfiable. Moreover, since each variable occurs twice, step (2.1) eliminates all occurrences of $x$. Furthermore, with the promise from (0) that there are no two complementary unit clauses, this step can not result in the empty clause. Hence, resulting set is an instance of the problem {\bf Read-$2$ SAT} that is satisfiable, if and only of the original instance was satisfiable. However, the only difference is this instance is shorter by at least one variable. Therefore, the whole proceeder is linearly bounded by the number of variables in $\varphi$. Therefore, after at most $| \mathit{Var}(\varphi)|$ steps, this algorithm will terminate, if it does not return false during its run time, the resulting empty set of clauses is equi-satisfiable to the original set of clauses.  



\bigskip


 \item {\bf All-Resolve-SAT}:  The input formula $F$ is a  CNF, and
 each pair of distinct clauses $c$ and $c'$ of $F$ resolves, i.e.,
 there is a variable $x$ such that $c = x \lor \alpha$ and $c' = \neg
 x\lor   \beta$ or the other way round ($c = \neg x \lor \alpha$ and
 $c' = x\lor \beta$)

 Examples:  $F=x\land \neg x$;  $G = (x \lor y) \land (\neg x \lor z)
 \land (\neg z \lor \neg y)$ \\
 
 
 
\emph{Observation 1: Consider a set of clauses $\Gamma$ over $m$ variables, such that each $C \in \Gamma$ contains $m$ unique variables, i.e. $|\mathit{Var}(C)|=m$. $\Gamma$ is satisfiable if and only if $|\Gamma|<2^m$, i.e. if there are strictly less than $2^m$ unique clauses in $\Gamma$. }


Firstly, there can be at most $2^m$ unique clauses. That is, with every clause having $m$ unique variables it follows that $\mathit{Var}(\Gamma)=\mathit{Var}(C)$ for each $C$. Now since every variable can occur either positively or negatively there are $2^m$ combinations, and thus $2^m$ clauses. 
Secondly, clearly if $|\Gamma|=2^m$ $\Gamma$ is unsatisfiable. That is, for each clause $C \in \Gamma$ there exists a clause $\overline{C} \in \Gamma$ where for every literal in $C$, there exists its complement in $\overline{C}$.


Thirdly, consider the case $|\Gamma|<2^m$. Hence, there exists a clause $C \in\Gamma$ which does not have a complement $\overline{C} \in \Gamma$. Consider the assignment $\sigma_{C}$ induced by $C$, i.e. $\sigma_{C}(x)=1$ iff $x$ is a positive literal in $C$. Assume that there exist a clause $C' \in \Gamma$ such that $C'$ is not satisfied under $\sigma_C$. This would imply that for every positive literal of $C$, $C'$ contains its negative counterpart. Analogue for the negative literals in $C$. However, this would mean that $C'$ is actually $\overline{C}$, which clearly is impossible. \\


\emph{Observation 2: Let $C$ be a clause and let $x$ be a new variable not contained in $C$. $C$ is equivalent to $\{C \lor x , C\lor \neg x\}$. }

Clearly, any model satisfying $C$ satisfies $C \lor x $ and $C\lor \neg x$. On the other hand any model satisfying $C \lor x $ and $C \lor \neg x$ must satisfy $C$, as no model can satisfy $x$ and $\neg x$ at the same time.\\

Let $\mathcal{E}_x(\Gamma)= \bigcup_{C \in \Gamma} \{C \lor x , C\lor \neg x\}$ for some set of clauses $\Gamma$. As syntactic sugar let $\mathcal{E}_x(C)=\mathcal{E}_x(\{C\})$. Moreover, let $\mathcal{E}_V(C)$ be the set of clauses computed by applying the above extension presented in Observation 2 until every clause in the resulting set contains all variables in $V$. That is,
\begin{equation*}
\begin{split}
\mathcal{E}_{\emptyset}(\Gamma) &= \Gamma \\
\mathcal{E}_V(\Gamma) &= \mathcal{E}_x(\mathcal{E}_{V \setminus \{x\}}(\Gamma)) \quad \text{for some } x \notin \mathit{Var}(\Gamma) \text{ and } x \in \mathit{V}
\end{split}
\end{equation*}

\emph{Observation 3:  Let $V$ be a set of variables, s.t. $|V|=m$. Let $\Gamma$ be a set of clauses over $V$ and let $C \in \Gamma$ such that $|\mathit{Var}(C)|=n\leq m$ (unique variables) then $|\mathcal{E}_V(C)|=2^{m-n}$.}

For a clause with $n$ distinct variables applying $\mathcal{E}_V$ for $|V|=m$, will result $m-n$ applications of $\mathcal{E}_x$. At each iteration the input set is doubled, i.e. every clause in the input set is replaced by two clauses. Therefore, since starting with a clause set of size one, one obtains $2^{m-n}$ clauses in the final set.  \\



\emph{Observation 4: Let $\Gamma$ be a set of unique clauses without duplicate variables over the set of variables $V$, where $\forall C, C' \in \Gamma$ $C$ and $C'$ resolve. Then $\forall C, C' \in \Gamma \; C \neq C' \Rightarrow \mathcal{E}_V(C) \cap \mathcal{E}_V(C') = \emptyset$}


Assume that there are two distinct clauses $C$ and $C'$ in $\Gamma$ such that $ \mathcal{E}_V(C) \cap \mathcal{E}_V(C') \neq \emptyset$. Hence, $D \in  \mathcal{E}_V(C) \cap \mathcal{E}_V(C')$ exists. It is known that there exists a variable $x  \in \mathit{Var}(C) \cap  \mathit{Var}(C')$ such that, w.l.o.g., $x \in \mathit{Lit}(C)$ and $\neg x \in \mathit{Lit}(C')$. The operator $\mathcal{E}_V$ produces only clauses that are extensions of the original clauses without adding already existing variables. Hence, $\forall C_e \in \mathit{Var}(C) \; x  \in \mathit{Lit}(C_e)$ and $\forall C_e' \in \mathit{Var}(C') \; \neg x  \in \mathit{Lit}(C_e')$. Thus, forcing the conclusion that $D$ can not exist. \\


\emph{Observation 5: Let $\Gamma$ be a set of unique clauses without duplicate variables over the set of variables $V$, where $\forall C, C' \in \Gamma$ $C$ and $C'$ resolve. Then $\Gamma$ is satisfiable if and only if $\sum_{C \in \Gamma} | \mathcal{E}_V(C)|<2^{|V|}$.}

By assumption, all clauses in $\Gamma$ are unique and resolve pairwise, while having no duplicate variables. Hence, by Observation 4, it follows that $|\bigcup_{C \in \Gamma} \mathcal{E}_V(C)|= \sum_{C \in \Gamma} | \mathcal{E}_V(C)|$. Now, by Observation 1, one knows that $\mathcal{E}_V(\Gamma)$ is satisfiable if and only if $|\mathcal{E}_V(\Gamma)|< 2^{|V|}$. Lastly, from Observation 2 it is known that $\mathcal{E}_V$ preserves validity. Therefore, $\mathcal{E}_V(\Gamma)$ is satisfiable iff $\Gamma$ is satisfiable.  \\


\emph{Observation 6: Let $\Gamma$ be a set of clauses over the set of variables $V$, where $\forall C, C' \in \Gamma$ $C$ and $C'$ resolve. Then $\Gamma$ testing satisfiability can be done in quadratic (probably linear) time wrt. to the combined length of the clauses in $\Gamma$.}

Firstly, iterate over all clauses and check if they contain duplicate variables, If so remove all duplicates. This operation is clearly save.
Secondly, iterate over all clauses and check for duplicates. Both operations can be done in linear time (or at least in quadratic time, if one is not smart about it). The resulting $\Gamma'$ is now a pairwise resolving set of unique clauses without duplicate variables over the set of variables $V$
By Observation 5 it is known that $\Gamma'$ is satisfiable if and only if $\sum_{C \in \Gamma} | \mathcal{E}_V(C)|<2^{|V|}$. By Observation 3, one has the equality $|\mathcal{E}_V(C)|=2^{|V|-|\mathit{Var}(C)|}$. Hence, one obtains $\sum_{C \in \Gamma} | \mathcal{E}_V(C)|= \sum_{C \in \Gamma} | 2^{|V|-|\mathit{Var}(C)|}| <2^{|V|}$. And since this sum only requires the length of the original clause and the exponent can also be computed in linear time one only has to compute the given some to decide satisfiability of $\Gamma$.


\bigskip

\item Bonus: determine whether {\bf Read-$k$ SAT}, where $k>1$ is fixed, is
tractable, for each $k$. \\

For $k=2$ see the actual exercise. Hence, consider an arbitrary $k>2$. Any of those {\bf Read-$k$ SAT} is not tractable, which can be shown through the reductions $\textbf{CNF} \leq_m^P\textbf{Read-}3 \,\textbf{SAT}$ and $\textbf{Read-}3\,\textbf{SAT} \leq_m^P\textbf{Read-}k \,\textbf{SAT}$. Starting with the prior. Let $\varphi$ be some CNF-formula, where $\mathit{Var}(\varphi):=\{x_1,\dots , x_n\}$ and where $\mathit{Cl}(\varphi):=\{C_1, \dots C_m\}$ such that no variable occurs twice in the same clause. This assumption is sound, because 
\begin{itemize}
\item  if a variable occurs multiple times in the same clause with the same polarity, i.e. either only positively or only negatively, all but one of those occurrences can be removed;
\item if a variable occurs both positively and negatively in a clause this clause can be removed;
\end{itemize}
and checking this can clearly be done in polynomial time.
Moreover, let $x_{ij}$ for $i \in \{1,\dots , n\}$ and $j \in \{1,\dots, m\}$ be fresh variables. Now consider $\tau$
\begin{equation*}
\begin{split}
\tau(\varphi) := & \psi = \psi_c \land \psi_e \\
= &\bigwedge_{j \in \{1,\dots , m\}} C[x_1 / x_{1j}, \dots , x_n / x_{nj}]  \land \\
& \bigwedge_{i \in \{1,\dots , n\}}  \big(   (\neg x_i \lor x_{i1})  \land  \bigwedge_{j \in \{1,\dots , m-1\}}  (x_{ij}  \lor \neg x_{i(j+1)})  \land (\neg x_{im} \lor x_{i})\big)
\end{split}
\end{equation*}

Firstly, the $ \psi_e$ forces for each variable $x_i$ that the following circle of implications is uphold $x_i \Rightarrow x_{i1} \Rightarrow  x_{i2} \Rightarrow \dots  x_{im} \Rightarrow x_i$, i.e. it expresses equality among all $x_{ij}$ for all $j\in \{1, \dots ,m\}$ and with $x_i$.
Secondly, each $x_{ij}$ occurs at most once in $\mathit{Var}(\psi)$, since $x_i$ occurs at most once in the clause $C_j$. Moreover, $x_{ij}$ occurs clearly exactly twice in $\psi_e$. Therefore, each variable occurs at most three times in $\psi$. 
Thirdly, $\psi_c$ is the same size as $\varphi$ and $\psi_e$ is linear with respect to the number of clauses times the number of variables in $\varphi$. Hence, the transformation can be done in polynomial time. \\

Lastly, it has to be demonstrated that $\varphi \; \mathit{sat.} \iff \psi \; \mathit{sat.} $.


$"\Rightarrow"$. If $\varphi$ is satisfiable, then there exists an assignment $\sigma$ under which $\varphi$ is satisfiable. Let $\sigma_{\tau}$ be an extension of $\sigma$ such that $\sigma_{\tau}:= \sigma \cup \{ x_{ij} \mapsto \sigma(x_i) \mid \forall i \in \{1,\dots ,n\} \forall j \in \{ 1, \dots, m\}\}$. Meaning that under this interpretation $x_i$ is replaced in $\psi_c$ with an object of the same truth value. Hence, $\psi_c$ is satisfied under $\sigma_{\tau}$. Moreover, with $\psi_e$ encoding a series of equivalences between $x_{ij}$ and $x_i$ for some fixed $i$, this assignment, ensuring equal evaluation of exactly those variables, must therefore satisfy $\psi_e$ as well.


$"\Leftarrow"$. if $ \psi$ is satisfiable, then there exists an assignment $\sigma$ under which $\psi$ is satisfiable. Under this assignment every variable in the set $\{x_i\}  \cup \{ x_{ij} \mid \forall j \in \{ 1, \dots, m\}\}$ for any fixed $i$ must be evaluated the same. Otherwise, $\psi_e$ would not have been satisfied. Hence, $\psi_c$ is satisfied by an assignment where every instance of $x_i$ has the same truth value. Therefore, by restricting $\sigma$ to the variables in $\varphi$ results in an satisfying assignment for $\varphi$.
 
 

The reduction $\textbf{Read-}3\,\textbf{SAT} \leq_m^P\textbf{Read-}k \,\textbf{SAT}$ is trivial. Meaning, any instance of $\textbf{Read-}3\,\textbf{SAT} $ of $\textbf{Read-}k \,\textbf{SAT}$. Hence, if $\textbf{Read-}k \,\textbf{SAT}$ would be tractable, then $\textbf{Read-}3\,\textbf{SAT}$ must be as well, which by transitivity would mean that $\textbf{CNF}$ would can be solved in deterministic polynomial time.


\end{itemize}


\newpage

\item[CT.5] (10) \label{WSAT} Consider the following variant of {\bf SAT}, called {\bf Weighted
     SAT}: the instance consists of a (propositional) CNF $F =
        \bigwedge_{i=1}^m c_i$, integer weights $w(c_i)>0$ for all
        clauses $i=1,\ldots,m$.

     A {\em maximum weight assignment}\/ is a truth assignment
    $\sigma$ to the variables in $F$ such that the total weight of
                clauses satisfied by $\sigma$, i.e.,
    $ w(\sigma) = \sum_{i=1}^k w(c_i)*\sigma(c_i)$,  is maximum. 
              
 \begin{enumerate}

       \item Show that, given an integer $k \geq 0$, deciding whether
            $w(\sigma)\geq k$ for some maximum weight assignment
                $\sigma$ is \NP-complete. 

                                
       \item Show that, deciding whether for any maximum weight assignment
                $\sigma$, the number $w(\sigma)$ is even is $\DeltaP{2}$-complete. 
                                
 \end{enumerate}

Bonus: Given an integer $k \geq 0$, what is the complexity of deciding whether
            $w(\sigma)\leq k$ for every maximum weight assignment
            $\sigma$ ?

 
 \bigskip

\emph{Solution:}           
           
             \begin{enumerate}

       \item Show that, given an integer $k \geq 0$, deciding whether
            $w(\sigma)\geq k$ for some maximum weight assignment
                $\sigma$ is \NP-complete. \\
       
Let the problem described above be called  $k\text{-}\textbf{WSAT}$
First hardness will be shown by giving a polynomial time reduction from {\bf CNF} to $k\text{-}\textbf{WSAT}$. Hence, by giving such a reduction it follows that $k\text{-}\textbf{WSAT}$ has to be at least \NP-hard. Otherwise, \textbf{CNF} would not be \NP-hard.
To establish $\textbf{CNF} \leq_m^P k\text{-}\textbf{WSAT}$, it has to be shown that there exists function $\tau$ that is computable in polynomial time wrt. to its input size such that for all inputs $x$, $\chi_{\textbf{CNF}} (x)= \chi_{k\text{-}\textbf{WSAT}}(\tau(x))$ holds. \\

Firstly, let $\mathit{Cl}(\varphi)$ be the set of all clauses of an CNF-formula $\varphi$. Now, consider an input formula $\varphi$ for \textbf{CNF} and the following transformation:
\begin{equation*}
\tau(\varphi):= (\varphi, w, k)
\end{equation*}
where 
\begin{itemize}
\item $w(c)=1$ for all clauses $c \in \mathit{Cl}(\varphi)$;
\item $k=| \mathit{Cl}(\varphi) |$.
\end{itemize}

Assume that $\varphi$ is satisfiable, i.e. $\chi_{\textbf{CNF}} (\varphi)=1$. Hence, all of its clauses are satisfied by the truth assignment $\sigma$. Considering the weight function $w$ obtained through $\tau$ one obtains $w(\sigma) = \sum_{c \in \mathit{Cl}(\varphi)} w(c)*\sigma(c)= \sum_{c \in \mathit{Cl}(\varphi)}1*\sigma(c)  = |\mathit{Cl}(\varphi)|$. That is, all clauses are satisfied and all clauses have the weight $1$. Clearly, $\sigma$ is a maximum weight assignment, in fact by construction any other truth assignment satisfying $\varphi$ has the same weight as $\sigma$. Lastly, since $k= |\mathit{Cl}(\varphi)|$  it follows that $\chi_{k\text{-}\textbf{WSAT}}(\tau(\varphi))=1$.

Assume that $\varphi$ is not satisfiable, i.e. $\chi_{\textbf{CNF}} (\varphi)=0$. Meaning that there does not exist a truth assignment which satisfies all clauses in $\varphi$. That is, for all truth assignments $\sigma$ it follows that $w(\sigma) = \sum_{c \in \mathit{Cl}(\varphi)} w(c)*\sigma(c) =\sum_{c \in \mathit{Cl}(\varphi)}1*\sigma(c)   < |\mathit{Cl}(\varphi)|$. Hence,  no maximum weight assignment of weight greater or equal to $k$ exists, thus one obtains $\chi_{k\text{-}\textbf{WSAT}}(\tau(\varphi))=0$.

Lastly, it has to be established that $\tau$ can be computed in polynomial time. Since, $w$ is constant it can be constructed on constant time. Hence, the only computationally demanding task in the transformation is to count the number of clauses in $\varphi$. However, this can clearly be accomplished on linear time wrt. to the number of clauses and since those are bound by the size of the formula, one can conclude that $\tau$ can be computed in polynomial time. Hence, completing the reduction. \\


Having established  \NP-hardness, it remains to show \NP-membership. To do so a simple guess and check algorithm is sketched. 
                                
\texttt{
\begin{tabbing}
guess($\sigma$); /* guess a truth assignment for $\varphi$*/  \\
if $\sigma$ \=satisfies $\varphi$ and $w(\sigma) \geq k$ then: \\
     \> succeed; \\
else: \\
     \>  fail; \\
\end{tabbing}}

This algorithm returns the required results due to the fact that as soon as one has found an assignment with weight greater or equal $k$, it is clear that any maximal assignment $\sigma_{max}$ has to have a weight greater or equal to $k$ as well. Moreover, this algorithm employs the guess and check method introduced in the lecture. That is, first one guesses an assignment and then check whether this assignment satisfies the formula $\varphi$. As established in the lecture, this checking can be done in polynomial time. Similarly, summing up the weights can also be done in polynomial time. Hence, one can conclude that this algorithm establishes \NP-membership. Together with the previous result \NP-completeness follows in kind.

       \item Show that, deciding whether for any maximum weight assignment
                $\sigma$, the number $w(\sigma)$ is even is $\DeltaP{2}$-complete. 

Let the problem described above be called  $\textbf{e-WSAT}$            
Similarly, as before $\DeltaP{2}$-hardness will be established first. To that end a reduction from $\textbf{MSA}$ to  $\textbf{e-WSAT}$  , i.e.  $\textbf{MSA} \leq_m^P \textbf{e-WSAT}$  is presented. Hence, consider the following transformation $\tau$ where
\begin{equation*}
\tau(\pi(\chi), (x_1, \dots , x_n)) := (\psi, w)
\end{equation*}
where $\varphi:=\pi(\chi)$ is an equi-satisfiable CNF-version of the input formula $\chi$, i.e. $\pi$ is some standard CNF transformation (e.g. Tseytin transformation), and $(x_1, \dots , x_n)$ is a vector indicating an ordering over the set of variables in $\chi$, i.e. $\mathit{Var}(\chi)$. Moreover, for $n:=|\mathit{Var}(\chi)|$
\begin{equation*}
\begin{split}
\psi := &\psi_c \land \psi_x \land \psi_p = \big( \bigwedge_{C \in \mathit{Cl}(\varphi)} (\neg p \lor C) \big) \land \big( \bigwedge_{i \in \{1,\dots,n\}} x_i \big) \land p\\
w := & \{ (p) \mapsto  2^{n+1} +1\} \cup  \{(\neg p \lor C)  \mapsto 2^{n+2} \mid \forall C \in \mathit{Cl}(\varphi)\}\\ 
 & \cup \{  (x_i) \mapsto 2^{(n-i)} \mid \forall i \in \{ 1, \dots, n\}\} 
\end{split}
\end{equation*}
Since $\pi$ is known to be polynomial and the number of additional clauses is linear with respect to the number of variables in $\chi$, the whole transformation can be done in polynomial time. (Note: In an actual implementation one does not need to compute and store the exponents $2^i$, that is it suffices to store and compare the number $i$). \\


\emph{Fact 1: $2^n > \sum_{i=0}^{n-1} 2^i$.} \\

\emph{Observation 2: If there exists a satisfying assignment of the formula $\varphi$,  then $p$ is satisfied under every weight maximal assignment.}

Consider an weight maximal assignment $\sigma$ where $\sigma(p)=0$. This assignment clearly satisfies every clause in $\psi_c$ without relying on the variables $x_1, \dots , x_n$. Hence, in order for this assignment to be maximal all clauses in $\psi_x$ are satisfied. That is, the only clause not satisfied is $(p)$. However, $w(p) > \sum_{C \in \mathit{Cl}(\psi_x)} w(x)$. Meaning that as long as the same clauses in $\psi_c$ are satisfied, any assignment $\sigma'$ such that $\sigma'(p)=1$ has a greater weight that $\sigma$. Now, given the assumption that $\varphi$ is satisfiable, all clauses in $\psi_c$ can be satisfied, without fixing the assignment of $p$. Hence, if $\varphi$ is satisfiable, there exists at least one of such assignment, which then must be chosen by maximality. \\

\emph{
Observation 3: For two satisfying assignment of $\varphi$, $\sigma_1$ and $\sigma_2$ , $\sigma_1 \prec_{lex} \sigma_2$ with respect to the vector $(x_i)_{i \in \{1, \dots n\}}$, if and only if $w(\sigma_1) < w(\sigma_2) $.  }


Firstly, since both assignments satisfy $\varphi$, $p$  is always satisfied. Therefore, the order induced by the weight does only depend on which "variable" clause in $\psi_x$ is satisfied. Hence, it suffices to focus solely on that part.
Assume  $\sigma_1 \prec_{lex} \sigma_2$ with respect to the vector $(x_i)_{i \in \{1, \dots n\}}$ then there exists one $k$ such that for all $1 \leq i < k$ it holds that $\sigma_1(x_i)=\sigma_2(x_i)$ and that $\sigma_1(x_k)<\sigma_2(x_k)$, with the remaining variables being arbitrary. Now since $2^{k-1} > \sum_{i=0}^{k-2} 2^i$ the assignment of variables $x_i$ for $i>k$ is irrelevant, i.e. even if all variable clauses greater $k$ are satisfied they can not outweigh $w(x_k)$. Therefore the inequality $w(\sigma_2)>w(\sigma_1)$ must hold. 
Assuming that  $w(\sigma_1) < w(\sigma_2)$. For the subformula $\psi_x$, those have the form $\omega_1 := \sum_{i \in \{1, \dots, n\}} \sigma_1(x_i) \cdot 2^{n-i}$ and $\omega_2 := \sum_{i \in \{1, \dots, n\}} \sigma_2(x_i) \cdot 2^{n-i}$. Since $\omega_1 < \omega_2$, $\sigma_1$ and $\sigma_2$ must differ at least on one position. Let $k$ be the first of those differences. Similar as before, since satisfying the position $k$ outweighs every possible assignment of the variable clauses after $(x_k)$, i.e. $(x_i)$ for $k<i$, it must be the case that $\sigma_2(x_k)=1$ and   $\sigma_1(x_k)=0$, thus $\sigma_1 \prec_{lex} \sigma_2$.  \\


\emph{Observation 4: If $p$ is satisfied under a weight maximal assignment $\sigma$, then $\varphi$ is satisfied under $\sigma$.}

Since $\sigma(p)=1$, it follows that $(p)$ is satisfied. Additionally, since $w(C)>w(p)$ for any $C \in \mathit{Cl}(\psi_c)$, if any of the clauses in $\psi_c$ would not be satisfied, flipping the assignment of $p$ would increase the total weight of the assignment. However, with $\sigma$ being weight maximal, one can thus conclude that all clauses in $\psi_c$ are satisfied. Hence, $\sigma$ is also a satisfying assignment of $\varphi$. \\ 


Finally, those observations culminate in the following. \\

$"\Rightarrow"$: Assume that the instance $(\chi, (x_1, \dots , x_n))$ is a satisfying instance of the problem $\textbf{MSA}$. Hence, $\chi$ is satisfiable and the maximal lexicographical assignment $\sigma$ evaluates $x_n$ to $1$. Since, $\pi$ preserves satisfiability, in such a way that restricting an assignment for $\varphi:=\pi(\chi)$ to the variables only occurring in $\chi$ provides a model for $\chi$.  Meaning that every clause in $\mathit{Cl}(\varphi)$ is satisfiable. Hence, $p$ will be satisfied under any maximal weight assignment. Moreover, by assumption $x_n$ will be satisfied, thus the total weight of the assignment will be even. Furthermore, since $x_n$ is satisfied under the lexicographical maximal assignment, by Observation 3,  it must be satisfied under the weight maximal assignment as well. Thus it is a positive instance of $\textbf{e-WSAT}$.  


$"\Leftarrow"$: Assume that the instance $\psi$,  is a satisfying instance of the problem $\textbf{e-WSAT}$.  Meaning for some weight maximal assignment $\sigma$, $w(\sigma)$ is even. Recall $\varphi = \bigwedge_{(\neg x \lor C) \in \mathit{Cl}(\psi_c)} C$. There are two cases. 
\begin{itemize}
\item Case 1: $\sigma(p)=0$ and $\sigma(x_n)=0$\\
By Observation 2 $\varphi$, and therefore $\chi$, can not be satisfied. Since, $\sigma(p)=0$ all clauses in $\psi_c$ are satisfied. Hence, the variables $x_1, \dots , x_n$ can be chosen freely without interfering with the truth value of the clauses clauses in $\psi_c$. Thus, there exists an assignment $\sigma'$ that is the same $\sigma$, except $\sigma'(x_n)=1$. Clearly, $w(\sigma')>w(\sigma)$ and $w(\sigma')$ odd. Implying the impossibility of this case.


\item Case 2: $\sigma(p)=1$ and $\sigma(x_n)=1$\\
Since, $\sigma$ is weight maximal, it follows form Observation 4, that $\varphi$ is satisfied under $\sigma$ such that $\sigma(x_n)=1$. Moreover, from this and from Observation 3, it follows that the weight maximal assignment is also the lexicographical maximal assignment. Thus by restricting $\sigma$ to the variables in $\chi$ one obtains a lexicographical maximal assignment in which $x_n$ evaluates to $1$. Hence, the original problem is a positive instance of $\textbf{MSA}$. 
\end{itemize} 

\bigskip
In a last step membership has to be shown. In order to establish membership, it suffices to give an appropriate algorithm. The idea of which is fairly simple:
\begin{itemize}
\item Use an algorithm $\mathcal{A}_{WSAT}(\varphi, k)$ that solves for $k\text{-}\textbf{WSAT}$ as an oracle. 
\item Check if there exists a satisfying assignment, if there does not return false. 
\item Otherwise, run binary search to find the greatest $k$, such that $\forall n > k$ the input ($\varphi$, $n$) is no longer an accepted instance of $k\text{-}\textbf{WSAT}$.
\item if $k$ is even return true; else return false
\end{itemize}
If there exists a solution, this program will return a smallest satisfying assignment. Moreover, since the complexity of binary search is $\mathcal{O}(log n)$, the oracle will be called upon at most a logarithmic amount of times, wrt. to the total weight 
%(which is smaller than the number of clauses times the greatest weight of an clause, the magnitude of both is smaller that the total size of the input).
Moreover, since those weights are some natural number their sum can be bounded by some exponent of $2^{f(|\mathit{Cl}(\varphi)|)}$ for some polynomial function $f$. Hence, making it a polynomial number of calls to the oracle, wrt. to the number of clauses.
 \texttt{
\begin{tabbing}
e-\=SAT($\varphi, w$): \\
\> $u:= \sum_{c \in \mathit{Cl}(\varphi)} w(c)$ \\
\> $l:= 0$ \\
\> while \=  $u \neq l$: \\
\>\> $n:= \lceil \frac{u+l}{2} \rceil$ \\
\>\> if \= $\mathcal{A}_{WSAT}(\varphi,n)=$ true: \\
\>\>\> $l:= n$ \\
\>\> else: \\ 
\>\>\> $u:= n-1$  \\
\> if $u$ is even: \\
\>\> return true \\
\> else: \\
\>\> return false \\
\end{tabbing}}


\item Bonus: Given an integer $k \geq 0$, what is the complexity of deciding whether
            $w(\sigma)\leq k$ for every maximum weight assignment
            $\sigma$ ?
            
As established above given an integer $k \geq 0$, deciding whether
 $w(\sigma)\geq k$ for some maximum weight assignment
$\sigma$ is \NP-complete. Written more concise 
\begin{equation*}
\exists \sigma \; (\sigma \; \textit{maximum weight assignment } \land  w(\sigma)\geq k)
\end{equation*}
                
Hence, the negation of this problem is, given an integer $k \geq 0$  
\begin{equation*}
\forall \sigma \; (\neg \sigma \; \textit{maximum weight assignment } \lor  \neg (w(\sigma)\geq k))
\end{equation*}
which is the same as
\begin{equation*}
\forall \sigma \; ( \sigma \; \textit{maximum weight assignment } \implies  w(\sigma)< k)
\end{equation*}
Therefore, the problem: Given an integer $k \geq 0$, what is the complexity of deciding whether $w(\sigma)\leq k$ for every maximum weight assignment $\sigma$. Is merely the negation of the problem $(k+1)\text{-}\textbf{WSAT}$. That is,
\begin{equation*}
\exists \sigma \; (\sigma \; \textit{maximum weight assignment } \land  w(\sigma)\geq k+1)
\end{equation*}
is equal to 
\begin{equation*}
\forall \sigma \; ( \sigma \; \textit{maximum weight assignment } \implies  w(\sigma)< k+1)
\end{equation*}
which is equal to 
\begin{equation*}
\forall \sigma \; ( \sigma \; \textit{maximum weight assignment } \implies  w(\sigma)\leq k)
\end{equation*}
Now, given the fact that $(k+1)\text{-}\textbf{WSAT}$ is \NP-complete, its complement is \coNP-complete.
 \end{enumerate}
         
  \newpage   
                       
\item[CT.6 ] (10) The class  ${\bf F}\Pol^\NP[log, wit]$
(cf.\ Unit 1) contains the search problems that can be solved in polynomial time with a
witness oracle, which loosely speaking returns some solution to a
problem in \NP (e.g., for {\bf SAT}, a satisfying assignment). 

A search problem $\Pi$ can be solved in $\FPNPlogwit$, if for
every instance $I$ of $\Pi$  some solution of $I$ can be computed in
polynomial time with a witness oracle for $\NP$, which can be consulted
at most $O(\log n)$ times, where $n=|I|$ is the length of the input.

\begin{enumerate}[(a)]
 \item show that computing some smallest (w.r.t.\ cardinality) model  of a
        Boolean formula is in $\FPNPlogwit$;
 \item show that computing some minimal (w.r.t.\ $\subseteq$) model of a
        Boolean formula is in $\FPNPlogwit$;
        
 \item Technically, $\FPNPlogwit$ requires that each input has some
 output, i.e., it consists of \emph{total (multi-valued) functions}\/ (thus, for computing a
 maximum model of a SAT instance $E$, a special value like ``unsat''
 is output in order to flag unsatisfiability); and each run produes output.

Show that $\FPNPlogwit \subseteq \FPNP$, where $\FPNP$ are the 
search problems $\Pi$ such that for
every instance $I$ of $\Pi$ some solution of $I$ can be computed in
polynomial time with an ``ordinary'' oracle for $\NP$.

Bonus: consider whether this inclusion would hold if problem instances
may have no solutions, and in this case computations do not generate output.
\end{enumerate}


\bigskip

\emph{Solution:}\\

WARNING: This whole exercise relies on the fact that $\mathbf{FSAT}$ is an $\mathbf{FNP}$-complete problem. 

\begin{enumerate}[(a)]
 \item show that computing some smallest (w.r.t.\ cardinality) model  of a
        Boolean formula is in $\FPNPlogwit$; \\
        
        
        
\emph{Observation 1: The problem $\textbf{FSAT}_{\leq k}$ taking an $k\in \mathbb{N}$ and an propositional formula $\varphi$ as input,  and returning a model of size smaller or equal to $k$ is \textbf{FNP}-complete. }

\emph{Membership:} Consider

 \texttt{
\begin{tabbing}
$\text{FSAT}_{\leq k}$\=($\varphi$, $k$): \\
\> $\mathcal{M}$ := guess($\varphi$)      // guess an assignment for $\varphi$ \\
\> if \= $|\mathcal{M}|\leq k$ and $\mathcal{M} \models \varphi$ : \\
\>\> return $\mathcal{M}$ \\
\> else : \\
\>\> return false \\
\end{tabbing}}
This algorithm is a guess and check algorithm running in polynomial time and returning, if possible, a result for the actual problem. Thereby establishing membership 



\emph{Hardness:} $\mathbf{FSAT}$ returns a model of any size, if $\varphi$ is satisfiable. Moreover, those model are at most of size $|\mathit{Var}(\varphi)|$. Therefore, it is clear to see that $\mathbf{FSAT}$ is merely an special case of  $\mathbf{FSAT}_{\leq k}$, namely $\mathbf{FSAT}_{|\mathit{Var}(\varphi)|}$. Given the fact that $\mathbf{FSAT}$ is $\mathbf{FNP}$-complete, one obtains $\mathbf{FNP}$-hardness.   \\




In order to establish membership, it suffices to give an appropriate algorithm. The idea of which is fairly simple:
\begin{itemize}
\item Use  $\mathbf{FSAT}_{\leq k}$ as an oracle. 
\item Check if there exists a satisfying assignment, if there does not return false. 
\item Otherwise, run binary search to find the smallest $k$, such that $\forall i < k$ the input ($\varphi$, $i$) is no longer an accepted instance of $\mathbf{FSAT}_{\leq i}$. 
\item return the last satisfying model.
\end{itemize}
If there exists a solution, this program will return a smallest satisfying assignment. Moreover, since the complexity of binary search is $\mathcal{O}(log n)$, the oracle will be called upon at most a logarithmic amount of times, wrt. the number of variables in $\varphi$.
Moreover, only the last call of $\mathbf{FSAT}_{\leq k}$ is important, all other calls could can also be done with a normal decision oracle.
To be more specific.

 \texttt{
\begin{tabbing}
Min-\=Card-SAT($\varphi$): \\
\> $u:= | \mathit{Var}(\varphi)|$ \\
\> $l:= 0$ \\
\> if \= $\text{FSAT}_{\leq k}(\varphi,u) =$ false: \\
\>\> return false \\
\> while $u \neq l$: \\
\>\> $n:= \lfloor \frac{u+l}{2} \rfloor$ \\
\>\> $\mathcal{M}:= \text{FSAT}_{\leq k}(\varphi,n) $ \\
\>\> if \= $\mathcal{M} =$ false: \\
\>\>\> $l:= n+1$ \\
\>\> else: \\ 
\>\>\> $u:= n$  \\
\> return $\mathcal{M}$  \\
\end{tabbing}}


 \item show that computing some minimal (w.r.t.\ $\subseteq$) model of a
        Boolean formula is in $\FPNPlogwit$;
        
        In order to establish membership, it suffices to give an appropriate algorithm. However, in this particular case membership directly follows form the following observation. \\
        
        
        
\emph{        Observation 2: Any minimal model with respect to cardinality is a subset minimal model.
        }
        
        
        This observation is trivial, as otherwise, there would be another model with less elements than a model with smallest number of elements. Which is clearly a contradiction. \\
        
        Since, the problem only requires the computation of \emph{some} subset minimal model, it is clear that this can be done by computing a smallest model with respect to cardinality. Therefore, establishing $\FPNPlogwit$ membership, through the runtime 	of \texttt{Min-Card-SAT($\varphi$)}.  \\
        
 \item Show that $\FPNPlogwit \subseteq \FPNP$, where $\FPNP$ are the 
search problems $\Pi$ such that for
every instance $I$ of $\Pi$ some solution of $I$ can be computed in
polynomial time with an ``ordinary'' oracle for $\NP$. 



The main idea required for showing that result is to use the concept of self-reducibility to show that it is possible to replace a single call to the \NP-complete witness oracle by a polynomial number of calls to a \NP-complete decision oracle. 
%However, to show self-reducibility of \NP-complete decision and search problems, two proof variants will be presented.  This is, due to the fact that the first one uses many notions not formally introduced in the course. For example, the fact that $\mathbf{FSAT}$ is \textbf{FNP}-complete, as well as the notion of reduction with respect to search problems.  
\\


\emph{
Observation 3: \textbf{SAT} is self-reducible}

That is, 
\begin{itemize}
\item Given an oracle of \textbf{SAT}, solve \textbf{FSAT} in polynomial time.
\item Given an oracle of \textbf{FSAT}, solve \textbf{SAT} in polynomial time.
\end{itemize}
The latter is trivial, i.e. ask \textbf{FSAT} once for a model, if a model is returned the formula in question is clearly satisfiable.
As for the prior, consider the following algorithm.

 \texttt{
\begin{tabbing}
FS\=AT($\varphi$): \\
\> If \= SAT($\varphi$) = FALSE: \\
\>\> return FALSE \\
\> $\sigma:= \{\}$    // Empty variable assignment  \\
\> for $x \in \mathit{Var}(\varphi)$: \\
\>\>	if \= SAT($\varphi \land x$) = TRUE:  \\
\>\>\> $\sigma := \sigma \cup \{x \mapsto 1\}$  \\
\>\>\> $\varphi := \varphi \land x$  \\
\>\>	else:  \\
\>\>\> $\sigma := \sigma \cup \{x \mapsto 0\}$  \\
\>\>\> $\varphi := \varphi \land \neg x$  \\
\> return $\sigma$
\end{tabbing}}

The first observation is that the algorithm above runs in polynomial time wrt. the number of variables. In fact, the number of calls to the oracle are linear. The second one, is that it produces a valid assignment. Thirdly, a formula has no model if and only if it is unsatisfiable. Hence, the algorithm above detects all negative cases. Lastly, having weeded out the negative cases, it has to be established that the algorithm always finds a model. To that end consider a partial assignment $\sigma_{(x_1, \dots , x_i)}$ of the variables $x_1, \dots , x_i \in \mathit{Var}(\varphi)$ such that there exists an extension $\sigma_{(x_1, \dots , x_n)}$ under which $\varphi$ is satisfiable. Furthermore, consider the variable $x_{i+1}$. Due to the guarantee that $\sigma_{(x_1, \dots , x_i)} $ can be extended, it follows that if $\sigma_{(x_1, \dots , x_i)} \cup \{x_{i+1} \mapsto 1\}$ can no longer be extended to a satisfying assignment, then $\sigma_{(x_1, \dots , x_i)} \cup \{x_{i+1} \mapsto 0\}$ must be, and vice versa. This is precisely, what happens in the \texttt{for}-loop. Meaning that at each step, the assignment is extended such that satisfiability is maintained. However, as the usual $\mathbf{SAT}$ problem does not take partial assignments as input, unit clauses are added, forcing a particular assignment of variables. \\


Now using this observation and the fact that $\mathbf{FSAT}$ is $\mathbf{FNP}$-complete, one can use the following polynomial time transformation.
\begin{itemize}
\item $\mathbf{FSAT}$ is $\mathbf{FNP}$-complete.
\item Any other $\mathbf{FNP}$-complete $\mathcal{P}_F$ can be reduced to $\mathbf{FSAT}$. 
\item $\mathbf{FSAT}$ can be solved by a polynomial number of calls to a $\mathbf{SAT}$ oracle.
\item However, $\mathbf{SAT}$ can be reduced to any other \NP-complete problem.
\end{itemize}
The other direction is trivial, i.e. similar as in the $\mathbf{SAT}$ case, the decision problem can be solved by solving the search problem.\\

Hence, for each $\mathbf{FNP}$-complete problem, there exists an algorithm that can transform said problem in its corresponding decision problem.\\

 The last remaining step is to show $\FPNPlogwit  \subseteq  \FPNP$. Consider an arbitrary problem $\mathcal{P}$ in \FPNPlogwit . Hence, there exists an algorithm $\mathcal{A}[\mathcal{Q}_F]$, that given an instance for $\mathcal{P}$, always returns a solution in polynomial time with a logarithmic number of calls to the witness oracle $\mathcal{Q}_F$. Meaning that $\mathcal{Q}_F$ is be some \textbf{FNP}-complete problem. Given the observation above, this oracle can be exchanged by its corresponding \NP-complete decision problem $\mathcal{Q}$ with just a polynomial time overhead. Let this algorithm be called $\mathcal{B}$ and thus $\mathcal{Q}_F= \mathcal{B}(\mathcal{Q})$. Hence, there resulting algorithm $\mathcal{A}'=\mathcal{A}[\mathcal{B}(\mathcal{Q})]$ is in \FPNP. \\
 
%(Actually, given my understanding the following should be sufficient. Since, $\FPNPlogwit = \mathbf{FP}^{\mathbf{FSAT}}[log]$, i.e. any $\mathbf{NP}$-witness oracle, and since $\mathbf{FSAT}$ reduces with polynomial overhead to $\mathbf{SAT}$ it follows $\mathbf{FP}^{\mathbf{FSAT}}[log] \subseteq \mathbf{FP}^{\mathbf{SAT}}$

\end{enumerate}
            
            

\newpage
            
\item[CW.1] (10) Give a formal proof that for a given propositional theory $T$,
CWA($T$) is consistent if and only if $T$ has a single  $\leq$-minimal model $M$. 

\bigskip

\emph{Solution:}\\

Note: Since consistency is a syntactic notion and minimal models are a semantic one, the following observations rely implicitly on the soundness and completeness of propositional logic.\\

\emph{Observation 1: Let $T$ be a consistent propositional theory, $\mathit{CWA}(T)= T \cup \{ \neg p \mid p \in \mathit{Var}(T) , \,\exists \mathcal{M} \in \mathit{MMod}(T) \; \mathcal{M} \models \neg p \}$ }


Consider the definition of the $\mathit{CWA}$, i.e. $\mathit{CWA}(T)= T \cup \{ \neg p \mid p \in \mathit{Var}(T) , \;T \nmodels p \}$.
By semantics of entailment one obtains the equality 
\begin{equation*}
 \{ \neg p \mid p \in \mathit{Var}(T), \;T \nmodels p \} = \{ \neg p \mid p \in \mathit{Var}(T), \, \exists \mathcal{M} \in \mathit{Mod}(T) \; \mathcal{M} \models \neg p \}.
\end{equation*}
Now, consider the definition of subset minimality. That is, for the two models $\mathcal{I}$ and $\mathcal{I}'$ of a formula $\chi$, $\mathcal{I}' \leq \mathcal{I}$ iff $\mathcal{I}' \subseteq \mathcal{I}$ iff $\forall p \mathit{Var}(\chi) \; \mathcal{I}' \models p \Rightarrow  \mathcal{I} \models p$. Hence, if there exists a model $\mathcal{M}$ such that $\mathcal{M} \models \neg p$ then there must be a minimal model $\mathcal{M}'$ also satisfying $\neg p$. Therefore, 
\begin{equation*}
\{ \neg p \mid p \in \mathit{Var}(T), \, \exists \mathcal{M} \in \mathit{Mod}(T) \; \mathcal{M} \models \neg p \} = \{ \neg p \mid p \in \mathit{Var}(T), \, \exists \mathcal{M} \in \mathit{MMod}(T) \; \mathcal{M} \models \neg p \}
\end{equation*}
Hence, arriving at
\begin{equation*}
\mathit{CWA}(T)= T \cup \{ \neg p \mid p \in \mathit{Var}(T), \, \exists \mathcal{M} \in \mathit{MMod}(T) \; \mathcal{M} \models \neg p \}
\end{equation*} \\

\emph{Observation 2: If $T$ is a satisfiable propositional theory such that $\mathit{MMod}(T):= \{\mathcal{M}_m\}$, then $CWA(T)$ is consistent.}

From Observation 1, one obtains that $\mathit{CWA}(T)= T \cup \{ \neg p \mid p \in \mathit{Var}(T), \, \exists \mathcal{M} \in \mathit{MMod}(T) \; \mathcal{M} \models \neg p \}$, which given the assumption about $T$ gives the equality
\begin{equation*}
\mathit{CWA}(T)= T \cup \{ \neg p \mid p \in \mathit{Var}(T), \; \mathcal{M}_m \models \neg p \}
\end{equation*} 
Clearly, $\mathcal{M}_m$ satisfies both $T$ and $ \{ \neg p \mid p \in \mathit{Var}(T),  \; \mathcal{M}_m \models \neg p \}$. Hence, by semantics it $\mathcal{M}_m$ satisfies the union of those sets. Therefore, $\mathcal{M}_m$ is a model of $\mathit{CWA}(T)$, thus establishing consistency. \\


\emph{Observation 3: If $T$ is a satisfiable propositional theory such that $|\mathit{MMod}(T)| > 1$, then $CWA(T)$ is inconsistent.}

From Observation 1, one obtains that $\mathit{CWA}(T)=T \cup \{ \neg p \mid p \in \mathit{Var}(T), \, \exists \mathcal{M} \in \mathit{MMod}(T) \; \mathcal{M} \models \neg p \}$. Hence, for any model $\mathcal{M}_{\mathit{CWA}}$ of  $\mathit{CWA}(T)$ it must be that 
\begin{equation*}
\mathcal{M}_{\mathit{CWA}} \cap \{ p \mid p \in \mathit{Var}(T), \, \exists \mathcal{M} \in \mathit{MMod}(T) \; \mathcal{M} \models \neg p \} = \emptyset
\end{equation*} 
Thus implying that 
\begin{equation*}
\mathcal{M}_{\mathit{CWA}} \subseteq \mathit{Var}(T)  \setminus \{ p \mid p \in \mathit{Var}(T), \, \exists \mathcal{M} \in \mathit{MMod}(T) \; \mathcal{M} \models \neg p \} 
\end{equation*} 
which is equivalent to 
\begin{equation*}
\mathcal{M}_{\mathit{CWA}} \subseteq \{ p \mid p \in \mathit{Var}(T), \,  \forall \mathcal{M} \in \mathit{MMod}(T) \; \mathcal{M} \models  p \} 
\end{equation*} 
Now consider the set $\{p \in \mathit{Var}(T) \mid  \forall \mathcal{M} \in \mathit{MMod}(T) \; \mathcal{M} \models  p\}$ this is the same as considering the intersection $\mathcal{M}_{\cap} := \bigcap_{\mathcal{M} \in \mathit{MMod}(T)} \mathcal{M}$. However, there are at least two distinct minimal models $\mathcal{M}_1$ and $\mathcal{M}_2$. Clearly, $\mathcal{M}_{\cap} \subset\mathcal{M}_1 $ and $\mathcal{M}_{\cap} \subset\mathcal{M}_2 $. Hence, if $\mathcal{M}_{\cap}$ would be a model of $T$, minimality of  $\mathcal{M}_1$ and $\mathcal{M}_2$ would be violated. Hence, $\mathcal{M}_{\cap} $ as well as any subset of it, can not be a model of $T$.
Thus only the interpretations $\mathcal{M}' \subseteq \mathcal{M}_{\cap}$ can model $ \{ \neg p \mid p \in \mathit{Var}(T), \, \exists \mathcal{M} \in \mathit{MMod}(T) \; \mathcal{M} \models \neg p \}$, while at the same time they can not be models of $T$. Hence, no model can satisfy $\mathit{CWA}(T)$, thereby rendering it inconsistent. \\


By negating Observation 3 one obtains "For $T$ being a satisfiable propositional theory. If $\mathit{CWA}(T)$ is consistent, then $|\mathit{MMod}(T)| =1$.". Together with Observation 2 one therefore obtains that, given a satisfiable propositional theory $T$, $\mathit{CWA}(T)$ is consistent if and only if $T$ has a single  $\leq$-minimal model $\mathcal{M}$. 
Lastly, assume that $T$ is not satisfiable, then trivially $\mathit{CWA}(T)$ can not be consistent and $|\mathit{MMod}(T)|=|\emptyset|\neq 1$.  Hence, allowing for arbitrary propositional theories, and thus the required claim is established. 

\newpage

\item[TCR.7]{(10)} Show that {\bf CF}$_G$ is $\PiP{2}$-hard by a reduction from
  Closed World Reasoning under the EGCWA, i.e., from EGCWA$(T)\models F$
  (which has the same complexity). Provide also a reduction in the other
  direction, i.e., from deciding EGCWA$(T)\models F$ to {\bf CF}$_G$.

Bonus: Consider the use of ECWA$(T;P;Z)$ in place of EGCWA$(T)$.\\


\bigskip

\emph{Solution:}\\

Firstly, $\textbf{CF}_G$ is the problem of deciding whether for some theory $T$ and two formulas $\varphi$ and $\psi$, $T\models \psi >_G \varphi$ holds. Which again is merely a shorthand for $T \circ_G \psi \models \varphi$. This leading to the definition of the two problems at hand.

$T \circ_G \psi \models \varphi	$ is equivalent to $ \{T' \cup \{\psi\} \mid T' \in W(\psi,T)\} \models \varphi$. Leading the completely unwrapped definition of 
\begin{equation*}
\{T' \cup \{\psi\} \mid T' \in  \max_{\subseteq}\{ T'' \subseteq T : T'' \nmodels \neg \psi\} \} \models \varphi
\end{equation*}
That is, $W(\psi,T)$ is the set of maximal sub-theories of $T$ that are consistent with $\psi$.
Hence, $T \circ_G \psi \models \varphi	$ expresses that all maximal $\psi$-consistent sub-theories of $T$ entail $\varphi$. \\

By contrast, $\mathit{EGCWA}(T) \models \varphi$ is equivalent to  
\begin{equation*}
T \cup \{\neg C \mid C \mathit{ \; conjunction \; of \; } a \in \mathit{Var}(T) , \;  \mathit{MMod}(T) \models \neg C  \} \models \varphi
\end{equation*}
with $\mathit{MMod}(T) \models \psi$ expressing that all minimal models wrt. positive information ($M \in \mathit{MMod}(T) \land M \subseteq M' \implies (\sigma_M(x)=1 \Rightarrow \sigma_{M'}(x)=1 )$) entail $\psi$.\\


\begin{itemize}


\item Starting with the reduction $\mathit{EGCWA}(T) \models \varphi  \leq_m^P \textbf{CF}_G $ for input $\tau(T,\varphi)$, where $\tau$ is defined as
\begin{equation*}
\tau(T, \varphi)  =  ( \mathit{KB}, T_{\land}, \varphi) = (\{ \neg x \mid \forall x \in \mathit{Var}(T)\}, \bigwedge_{\psi \in T} \psi, \varphi)
\end{equation*}
meaning that one obtains the problem $ \mathit{KB} \circ_G T_{\land} \models \varphi$. \\

\emph{Observation 1: If $T$ is satisfiable, then for $A \in W (\mathit{KB}, T_{\land})$, there exists exactly one model $\mathcal{M}$, such that $\mathcal{M} \models A \cup T$. \\}


Any model satisfying $A$ must evaluate all variables in $A$ as $0$. Therefore, any model of $\mathcal{M} \models A \cup T$ must build on the partial assignment  $\sigma_A := \{ x \mapsto 0 \mid \forall x \in \mathit{Var}(A)  \} $, i.e. $\sigma_A \subseteq \sigma_{\mathcal{M}}$. 
It is known that there exists a model $\mathcal{M}_A$ of $A$ such that $\mathcal{M}_A \models T_{\land}$. Claim, this model has the form $\mathcal{M}_A:=\{x \mid  \forall  x \in \mathit{Var}(T) \setminus \mathit{Var}(A)\}$. Assume it does not. That is, consider $\mathcal{M} \supset \mathcal{M}_A$. Thus, it would be possible to add $\mathcal{M}_A \setminus \mathcal{M}$ to $A$, while retaining the condition $A \nmodels \neg \psi$. Thereby, violating maximality. Hence, if there exists a smaller model of $A$, then $A$ is not maximal. Hence, $\mathcal{M}_A$ is the only model of $A$. Now, since there must exist a model of $A$ that satisfies $T_{\land}$ it follows that $\mathcal{M}_A$ is a model of $T_ {\land}$ and therefore the only model of $A \cup T$. \\

%Let $\mathcal{M}_A := \{ x \mapsto 0 \mid \forall x \in \mathit{Var}(A)  \} \cup  \{ x \mapsto 1 \mid \forall  x \in \mathit{Var}(T) \setminus \mathit{Var}(A) \}$. Claim $\mathcal{M}_A$ is the only model of $A \cup T$. Clearly, $\mathcal{M}_A$ models $A$. Moreover, there must be at least a model $\mathcal{M}'$ such  
%
%
%
%and with $A$ being a maximal subset of $\mathit{KB}$ such that there by construction $\mathcal{M}_A \nmodels \neg   \bigwedge_{\varphi \in T} \varphi $. If there would be another model $\mathcal{M}$ such that for some variable $c$, one has $\sigma_{\mathcal{M}}(c)=0$ and $\sigma_{\mathcal{M}_A}(c)=1$, for which  $\mathcal{M} \nmodels \neg   \bigwedge_{\varphi \in T} \varphi $ holds. One has found $A  \cup \{\neg c\}$ such that  $A  \cup \{\neg c\} \nmodels \neg   \bigwedge_{\varphi \in T} \varphi$, which clearly contradicts the maximality of $A$.  Therefore,  $\mathcal{M}$ can not satisfy $T$. \\
%
%Clearly, if 

\emph{Observation 2: For a given theory $T$, 
\begin{equation*}
\mathit{MMod}(T) = \bigcup_{A \in W( \mathit{KB} , T_{\land})} \{ \mathcal{M} \mid \forall \mathcal{M} \; \mathcal{M} \models A \cup T\}
\end{equation*}}
%=\{\mathcal{M} \mid \forall A \in W( \mathit{KB} , T_{\land})\forall \mathcal{M} \; \mathcal{M} \models A \cup T\}

%\{\mathcal{M}  \mid \exists A \in  \max_{\subseteq} \big\{ A' \subseteq  \{ \neg x \mid \forall x \in \mathit{Atom}(T)\} : A' \nmodels \neg  \bigwedge_{\varphi \in T} \varphi  \big\} \; \mathcal{M}  \models A \cup T\}
%\{\mathcal{M} \mid \exists A \subseteq_{max} \{ \neg x \mid \forall x \in \mathit{Atom}(T)\} \; \big( \mathcal{M} \models \bigwedge_{\varphi \in A} \varphi \mathit{\; and \; } \mathcal{M} \models  \bigwedge_{\varphi \in T}   \varphi \big)\}

If $T$ is not satisfiable, clearly 
\begin{equation*}
\mathit{MMod}(T) = \emptyset = \bigcup_{A \in W( \mathit{KB} , T_{\land})} \{ \mathcal{M} \mid \forall \mathcal{M} \; \mathcal{M} \models A \cup T\}
\end{equation*}


$" \Rightarrow "$: Take $\mathcal{M} \in \mathit{MMod}(T)$. Clearly, $\mathcal{M}$ models $T$ and thus $\mathcal{M} \models T_{\land}$. Using the induced assignment  $\sigma_{\mathcal{M}}$ construct $A_{\mathcal{M}}:= \{ \neg x \mid \forall x \in \mathit{Var}(T)\; \sigma_{\mathcal{M}}(x)=0 \}$, which is satisfied by $\mathcal{M}$ by construction. Hence, it remains to show that $A_{\mathcal{M}}$ is maximal. Assume that there exists a  $A_{\mathcal{M}'} \supset A_{\mathcal{M}}$, such that $\mathcal{M}'$ satisfies $T$ . Hence, there exists $x$, such that $\sigma_{\mathcal{M}'}(x)=0$, while $\sigma_{\mathcal{M}}(x)=1$. However, this contradict the minimality of $\mathcal{M}$. 


$" \Leftarrow "$: Take $\mathcal{M}_A \in\bigcup_{A \in W( \mathit{KB} , T_{\land})} \{ \mathcal{M} \mid \forall \mathcal{M} \; \mathcal{M} \models A \cup T\}$.
By construction $\mathcal{M}_A$ models $T$. It remains to show that $\mathcal{M}_A$ is minimal. Since, $A$ contains the maximal amount of negative literals such that $T$ is not contradicted (see observation 1), any model $\mathcal{M} \subset  \mathcal{M}_A$ can not be a model of $T$. Therefore, $\mathcal{M}_A$ is a minimal model of $T$.


Since $\mathcal{M} \models A \cup T$ is unique one could rewrite the statement to: for a given theory $T$, 
\begin{equation*}
\mathit{MMod}(T)=\{\mathcal{M}_A \mid \forall A \in W ( \mathit{KB}, T_{\land}) \; \mathcal{M}_A \models A \cup T\}
\end{equation*}

Using those observation one obtains the following. 

Assume that $\mathit{EGCWA}(T) \models \varphi$. Hence, $\forall \mathcal{M} \in \mathit{Mod}(\mathit{EGCWA}(T)) \; \mathcal{M} \models \varphi$, which given the theorem in the lecture slides, is equivalent to $\forall \mathcal{M} \in \mathit{MMod}(T) \; \mathcal{M} \models \varphi$. Now using the observation 2 one obtains the equivalent statement $\forall \mathcal{M} \in \{\mathcal{M}_A \mid \forall A \in W ( \mathit{KB}, T_{\land}) \; \mathcal{M}_A \models A \cup T\} \; \mathcal{M} \models \varphi$, which is equivalent to $  \mathit{KB} \circ_G   T_{\land}  \models \varphi$. \\


\bigskip


\item Secondly, the reduction $\mathit{KB} \circ_G \psi \models \varphi     \leq_m^P \mathit{EGCWA}(T) \models \varphi $, where $\tau$ is defined as $\tau(KB, \psi, \varphi)  = (T, \varphi) $ with $T$ being 
\begin{equation*}
\{\psi\} \cup \{ x_i \not\equiv y_i  \mid \forall x_i \in \mathit{Var}(\mathit{KB}  \cup \{\psi\})\} \cup 
 \left\lbrace  d_i    \lor \chi_i  \mid \forall \chi_i \in \mathit{KB} \right\rbrace 
\end{equation*}
where $y_i, d_i$ are some fresh propositional variables (including the variables in $\varphi$).  
As a shorthand let $T_{y}:=\{ x_i \not\equiv y_i  \mid \forall x_i \in \mathit{Var}(\mathit{KB}  \cup \{\psi\})\} $ and let $T_d:=\left\lbrace  d_i   \lor \chi_i  \mid \forall \chi_i \in \mathit{KB} \right\rbrace $ \\

First of all, this transformation can be done in polynomial time with respect to the amount of clauses  (for constructing $T_d$) and variables (for construction $T_y$).  \\

\emph{Observation 1:  $\mathit{MMod}(T_y) = \mathit{Mod}(T_y)$. } 

Clearly $\mathit{MMod}(T_y) \subseteq \mathit{Mod}(T_y)$. Consider $\mathcal{M} \in \mathit{Mod}(T_y)$ assume that there exists a $\mathcal{M}' \subset \mathcal{M}$. Hence, $\exists z \in \mathcal{M}\; z \notin \mathcal{M}'$. However, w.l.o.g. assume that $z=x_i$ then $\sigma_{ \mathcal{M}'}(x_i)=0$, this requires through $x_i \neq y_i$ that $\sigma_{ \mathcal{M}'}(y_i) = 1$ and thus $y_i \in \mathcal{M}'$. 
Clearly, $y_i \notin \mathcal{M}$. Hence, $\mathcal{M}' \not\subset \mathcal{M}$. Thus, $\mathcal{M}$ is minimal, i.e. $\mathcal{M} \in \mathit{MMod}(T_y)$ \\

Observation 2: There exists a bijection $\pi$ from $\bigcup_{\mathit{KB}' \in W(\psi, \mathit{KB})} Mod(\mathit{KB}' \cup \{\varphi\})$ to $\mathit{MMod}(T)$. Where 
\begin{equation*}
\pi(\mathcal{M}_K):=\mathcal{M}_T=\mathcal{M}_K \cup \{y_i \mid \forall (x_i \not\equiv y_i) \in T_y \; x_i \notin \mathcal{M}_K\} \cup
 \{ d_i \mid \forall (d_i \lor \chi_i) \in T_d \; \mathcal{M}_K \nmodels \chi_i\}
\end{equation*}
where its inverse is simply the removal of the added elements, i.e. $ \{y_i \mid \forall (x_i \not\equiv y_i) \in T_y \; x_i \notin \mathcal{M}_K\} \cup \{ d_i \mid \forall (d_i \lor \chi_i) \in T_d \; \mathcal{M}_K \nmodels \chi_i\}$.


First, it has to be demonstrated that $\mathcal{M}_T$ is actually a minimal model. Let $\mathcal{M}_K$ be an arbitrary model of $\mathit{KB}' \cup \{\varphi\}$  for some $\mathit{KB}' \in W(\psi, \mathit{KB})$. Clearly, $\mathcal{M}_K \cup \{y_i \mid \forall (x_i \not\equiv y_i) \in T_y \; x_i \notin \mathcal{M}_K\}$ satisfies $T_y$. By Observation 1, it follows that it is minimal. Hence, it is from now on only relevant, if a $\chi_i$ is satisfied, and not how it is satisfied. Speaking of which, since $\mathit{KB}'$ is a maximal subset of $\mathit{KB}$ that is still consistent with $\psi$, $\mathcal{M}_K$ must satisfy a maximal amount of $\chi_i$'s, i.e. adding any additional $\chi_i$ leads to inconsistency with $\psi$. Therefore, the set $\{\chi_i \mid \forall \chi_i \in \mathit{KB} \mathcal{M}_K \models \chi_i\}$ is maximal and thereby the set $\{\chi_i \mid \forall \chi_i \in \mathit{KB}  \mathcal{M}_K \nmodels \chi_i\}$ is minimal. Hence, only a minimal amount of $d_i$'s are satisfied, i.e. $ \{ d_{ij} \mid \forall (d_i \lor \chi_i) \in T_d  \; \mathcal{M}_K \nmodels \chi_i\}$ is minimal. Notice whether a model is minimal, depends solely on how many $d_i$'s it satisfies. Since, $d_i$ is only satisfied, if $\chi_i$ is not modelled by $\mathcal{M}_K$ and vice versa, $\mathcal{M}_T$ is minimal model of $T$. \\

% the case $\mathcal{M}_K \models \chi$ where $\chi \notin \mathit{KB}$, but $\chi \notin \mathit{KB}'$ can not arise. 
 
 
Secondly, one has to demonstrate that $\pi$ is surjective. Assume that there exists a model $\mathcal{M}_T \in \mathit{MMod}(T)$ and that there exists no $\mathcal{M}_K \in \bigcup_{\mathit{KB}' \in W(\psi, \mathit{KB})} Mod(\mathit{KB}' \cup \{\varphi\})$ such that $\pi(\mathcal{M}_K)=\mathcal{M}_T$. Clearly, $\mathcal{M}_T$ is of the form $\mathcal{M}_X \cup \{y_i \mid \forall (x_i \not\equiv y_i) \in T_y \; x_i \notin \mathcal{M}_K\} \cup
 \{ d_i \mid \forall (d_i \lor \chi_i) \in T_d \; \mathcal{M}_K \nmodels \chi_i\}$ for some partial model $\mathcal{M}_X$. 
 Moreover, $\mathcal{M}_X$ induces an assignment on the variables $x_i$.
% Moreover, since $\mathcal{M}_T$ satisfies it must be that $\mathcal{M}_T \cap \mathit{Var}(\mathit{KB})$.
Since, $\mathcal{M}_T$ is minimal, either $d_i$ or $\chi_i$ is satisfied. Since, $d_i$ is more expensive it follows that, a maximal amount of $\chi_i$ will be satisfied.
%, i.e. $\mathcal{M}_T \nmodels \neg \psi$, but $(\mathcal{M}_T \cup \{ \chi_j\}) \setminus \{d_j\} \models \neg \psi$. 
Therefore, $\mathcal{M}_X$ satisfies a maximal amount of $\chi_i$, as their truth value only depends on the values of $x_i$'s. Thus, it is a model of the set, $\{ \chi_i \mid \forall \chi_i \in \mathit{KB} \; \mathcal{M}_K \models \chi_i \} \in W(\psi, \mathit{KB})$ for some model $\mathcal{M}_K$.\\


Thirdly, $\pi$ is injective due to the fact that the assignments of the variables $y_i$'s and $d_i$'s are uniquely determined by the assignment of $x_i$'s. \\


Finally, one can tackle the reduction. Let $\pi$ be the bijection from Observation 2.

$" \Rightarrow "$: Assume that $\mathit{KB} \circ_G \psi \models \varphi $. Meaning that $\forall \mathit{KB}' \in W(\psi, \mathit{KB})$  and $\forall \mathcal{M}_K$ such that $\mathcal{M}_K \models \mathit{KB}' \cup \{\varphi\}$, it holds that $\mathcal{M}_K \models \varphi$. Which is precisely the domain of $\pi$. Since, $\mathcal{M}_T=\pi(\mathcal{M}_K)$ is an extension of $\mathcal{M}_K$ by variables that are not present in $\varphi$ one obtains $\mathcal{M}_T \models \varphi$. As established above $\mathcal{M}_T \in \mathit{MMod}(T)$, thus through the fact that $\pi$ is bijective one obtains $\mathit{MMod}(T)  \models \varphi$.

$" \Leftarrow "$: Assume that $\mathit{MMod}(T)  \models \varphi$. Take an arbitrary model $\mathcal{M}_T \in \mathit{MMod}(T)$, since the truth value of $\varphi$ does not depend on the variables $y_i$ and $d_i$ in the sentences $T_y$ and $T_d$ respectively, one can safely restrict the model to $\mathcal{M}_X$ in $\mathcal{M}_X \cup \{y_i \mid \forall (x_i \not\equiv y_i) \in T_y \; x_i \notin \mathcal{M}_K\} \cup
 \{ d_i \mid \forall (d_i \lor \chi_i) \in T_d \; \mathcal{M}_K \nmodels \chi_i\}$, which is incidentally $\pi^{-1}(\mathcal{M}_T)$. Thus, $\pi^{-1}(\mathcal{M}_T) \models \varphi$. With $\mathcal{M}_T$ arbitrary and $\pi$ bijective.

\bigskip


\item Bonus: Consider the use of ECWA$(T;P;Z)$ in place of EGCWA$(T)$.\\

As a reminder 
\begin{itemize}
\item $P \dots $ atoms to be minimized;
\item $Q \dots $ atoms that are fixed;
\item $Z \dots $ atoms that may take arbitrary value when minimizing P;

\end{itemize}

The reduction $\mathit{KB} \circ_G \psi \models \varphi     \leq_m^P \mathit{ECWA}(T;P;Z) \models \varphi $, is the same as the one on the main exercise, i.e. $\mathit{KB} \circ_G \psi \models \varphi     \leq_m^P \mathit{EGCWA}(T) \models \varphi$. This results from the fact that EGCWA $=$ ECWA where $Q = Z = \emptyset$. \\

Moving on to the reduction, $\mathit{ECWA}(T;P;Z) \models \varphi  \leq_m^P \textbf{CF}_G $ for input $\tau(T,\varphi)$, where $\tau$ is defined as
\begin{equation*}
\tau(T;P;Z, \varphi)  =  ( \mathit{KB}, T_{\land}, \varphi) = (\{ \neg x \mid \forall x \in P\}, \bigwedge_{\psi \in T} \psi, \varphi)
\end{equation*}
where 
\begin{equation*}
\begin{split}
\mathit{KB}  &:=  \{ \neg p \mid \forall p \in P\} \cup \{ \neg q \mid \forall q \in Q\} \cup \{ \neg q \mid \forall q \in Q\} \\
 T_{\land} &:=   \bigwedge_{\psi \in T} \psi 
\end{split}
\end{equation*}
%\big( \bigwedge_{q \in Q}  q   \not\equiv x_q  \big) \land
%ans with $x_q$'s being fresh variables.
Meaning that one obtains the problem $ \mathit{KB} \circ_G T_{\land} \models \varphi$. \\


Firstly, notice due to the fact that no atom $z \in Z$ occurs in $\mathit{KB}$, $z$ is neither minimised nor fixed and can therefore be chosen in an arbitrary manner to satisfy $T_{\land}$. \\


\emph{Observation 1:  Two subsets $\mathit{KB}'$ and $\mathit{KB}''$ of $\mathit{KB}$ that are consistent with $T_{\land}$ are only comparable if $Q \cap \mathit{KB}' =Q \cap \mathit{KB}''$. 
}

This is, due to the fact that the subset has to be consistent with $T_{\land}$. Hence, the subset itself must be consistent. However, with $z$ and $\neg z$ being complementary, it can never be that both are present in such a subset of $\mathit{KB}$. That is, $q \in \mathit{KB}' \land q \notin \mathit{KB}'' $  implies  $\neg q \notin \mathit{KB}' \land \neg q \in \mathit{KB}'' $. \\


\emph{Observation 2: For a given theory $T$, 
\begin{equation*}
\mathit{MMod}(T;P;Z) = \bigcup_{A \in W( \mathit{KB} , T_{\land})} \{ \mathcal{M} \mid \forall \mathcal{M} \; \mathcal{M} \models A \cup \{T_{\land} \}\}
\end{equation*}}
%=\{\mathcal{M} \mid \forall A \in W( \mathit{KB} , T_{\land})\forall \mathcal{M} \; \mathcal{M} \models A \cup T\}

%\{\mathcal{M}  \mid \exists A \in  \max_{\subseteq} \big\{ A' \subseteq  \{ \neg x \mid \forall x \in \mathit{Atom}(T)\} : A' \nmodels \neg  \bigwedge_{\varphi \in T} \varphi  \big\} \; \mathcal{M}  \models A \cup T\}
%\{\mathcal{M} \mid \exists A \subseteq_{max} \{ \neg x \mid \forall x \in \mathit{Atom}(T)\} \; \big( \mathcal{M} \models \bigwedge_{\varphi \in A} \varphi \mathit{\; and \; } \mathcal{M} \models  \bigwedge_{\varphi \in T}   \varphi \big)\}

If $T$ is not satisfiable, clearly 
\begin{equation*}
\mathit{MMod}(T;P;Z) =\emptyset =\bigcup_{A \in W( \mathit{KB} , T_{\land})} \{ \mathcal{M} \mid \forall \mathcal{M} \; \mathcal{M} \models A \cup \{T_{\land} \}\}
\end{equation*}



$" \subseteq "$: Take $\mathcal{M} \in \mathit{MMod}(T;P;Z)$. Hence, $\mathcal{M} \models T_{\land}$. Using this the a subset $A:=\{ \neg z \mid \forall x \in \mathit{KB}\; \mathcal{M}_K \nmodels z \}$ of $\mathit{KB}$ is constructed. $\mathcal{M}$ is a $\leq_{P;Z}$-minimal model. Meaning that, for the class of models with a particular subset $Q'$ of $Q$, $\mathcal{M}$ is subset minimal with respect to the atoms in $P$. Through Observation 1, one obtains that two subsets of $\mathit{KB}$ consistent with $T_{\land}$ are only comparable if they share the same subset of $Q$. Therefore, with $\mathcal{M}$ being subset minimal with respect to elements in $P$ for a fixed subset of $Q$, it follows that $A$ contains a maximal amount of $\neg p$ for $p\in P$ for a given subset of $Q$. Hence, $A$ is a maximal consistent subset of $\mathit{KB}$ that is consistent with $T_{\land}$ and that is by construction satisfied by $\mathcal{M}$. Thus showing the first inclusion.

$" \supseteq "$: Take $\mathcal{M} \in  \bigcup_{A \in W( \mathit{KB} , T_{\land})} \{ \mathcal{M} \mid \forall \mathcal{M} \; \mathcal{M} \models A \cup \{T_{\land} \}\}$. Let $Q_{\mathcal{M}} = \mathcal{M} \cap Q$, $P_{\mathcal{M}} = \mathcal{M} \cap P$, $Z_{\mathcal{M}} = \mathcal{M} \cap Z$. For this particular model, there exists at least one $A \in W( \mathit{KB} , T_{\land})$ such that $\mathcal{M}\models A$. By Observation 1, if for another $A'\in W( \mathit{KB} , T_{\land})$, $A \subseteq A' \lor A' \subseteq A$ holds then $Q \cap A = Q \cap A'$. Furthermore, since $A$ forces a particular assignment of the atoms in $Q$, i.e. either $z \in A$ or $\neg z \in A$ and by consistency never both, one obtains $Q_{\mathcal{M}}  =A \cap Q $. Now assume that there exists an model $\mathcal{M}' \leq_{P;Z} \mathcal{M}$. That is, $\exists \mathcal{M}' \; \mathcal{M}' \leq_{P;Z} \mathcal{M} \land  \mathcal{M} \nleq_{P;Z} \mathcal{M}' $, since by assumption the first part of the conjunction holds, it follows that the second part can only hold if $\mathcal{M}' \cap P \subset \mathcal{M} \cap P$. Hence, $\mathcal{M} \cap Q = \mathcal{M} \cap Q$ and $\mathcal{M}' \cap P \subset \mathcal{M} \cap P$. However, as seen in Observation 1 of the first reduction of the whole exercise. This can not be the case. Otherwise, $A$ does not contain the maximal number of negative atoms of $P$. (Explanation: That is, if there would be a $p \in \mathcal{M}$ that is not in $\mathcal{M}'$, then $\neg p \in A$ by maximality, and under the assumption that $\mathcal{M}'$ is a model of $A$ would imply that $\mathcal{M}$ is not. ). Hence, $\mathcal{M} \in \mathit{MMod}(T;P;Z)$. \\


Lastly, by the same argumentation as above (i.e. first reduction of this exercise) one can conclude that $ \mathit{ECWA}(T;P;Z) \models \varphi $ if and only if  $\mathit{KB} \circ_G \psi \models \varphi  $ such that $\tau(T;P;Z, \varphi) =  \mathit{KB}, T_{\land}, \varphi) $.

%
%Clearly, $\mathcal{M}$ models $T$ and thus $\mathcal{M} \models T_{\land}$. Using the induced assignment  $\sigma_{\mathcal{M}}$ construct $A_{\mathcal{M}}:= \{ \neg x \mid \forall x \in \mathit{Var}(T)\; \sigma_{\mathcal{M}}(x)=0 \}$, which is satisfied by $\mathcal{M}$ by construction. Hence, it remains to show that $A_{\mathcal{M}}$ is maximal. Assume that there exists a  $A_{\mathcal{M}'} \supset A_{\mathcal{M}}$, such that $\mathcal{M}'$ satisfies $T$ . Hence, there exists $x$, such that $\sigma_{\mathcal{M}'}(x)=0$, while $\sigma_{\mathcal{M}}(x)=1$. However, this contradict the minimality of $\mathcal{M}$. 
%
%
%$" \Leftarrow "$: Take $\mathcal{M}_A \in\bigcup_{A \in W( \mathit{KB} , T_{\land})} \{ \mathcal{M} \mid \forall \mathcal{M} \; \mathcal{M} \models A \cup T\}$.
%By construction $\mathcal{M}_A$ models $T$. It remains to show that $\mathcal{M}_A$ is minimal. Since, $A$ contains the maximal amount of negative literals such that $T$ is not contradicted (see observation 1), any model $\mathcal{M} \subset  \mathcal{M}_A$ can not be a model of $T$. Therefore, $\mathcal{M}_A$ is a minimal model of $T$.
%
%
%
%
%




%
%\emph{Observation 1: If $T$ is satisfiable, then for $A \in W (\mathit{KB}, T_{\land})$, there exists exactly one model $\mathcal{M}$, such that $\mathcal{M} \models A \cup T$. \\}
%
%
%Any model satisfying $A$ must evaluate all variables in $A$ as $0$. Therefore, any model of $\mathcal{M} \models A \cup T$ must build on the partial assignment  $\sigma_A := \{ x \mapsto 0 \mid \forall x \in \mathit{Var}(A)  \} $, i.e. $\sigma_A \subseteq \sigma_{\mathcal{M}}$. 
%It is known that there exists a model $\mathcal{M}_A$ of $A$ such that $\mathcal{M}_A \models T_{\land}$. Claim, this model has the form $\mathcal{M}_A:=\{x \mid  \forall  x \in \mathit{Var}(T) \setminus \mathit{Var}(A)\}$. Assume it does not. That is, consider $\mathcal{M} \supset \mathcal{M}_A$. Thus, it would be possible to add $\mathcal{M}_A \setminus \mathcal{M}$ to $A$, while retaining the condition $A \nmodels \neg \psi$. Thereby, violating maximality. Hence, if there exists a smaller model of $A$, then $A$ is not maximal. Hence, $\mathcal{M}_A$ is the only model of $A$. Now, since there must exist a model of $A$ that satisfies $T_{\land}$ it follows that $\mathcal{M}_A$ is a model of $T_ {\land}$ and therefore the only model of $A \cup T$. \\

\end{itemize}

%
%Secondly, the reduction $\mathit{KB} \circ_G \psi \models \varphi     \leq_m^P \mathit{EGCWA}(T) \models \varphi $, where $\tau$ is defined as $\tau(KB, \psi, \varphi)  = (T, \varphi) $ with $T$ being 
%\begin{equation*}
%\{\psi\} \cup \{ x_i \not\equiv y_i  \mid \forall x_i \in \mathit{Var}(\mathit{KB}  \cup \{\psi\})\} \cup 
% \left\lbrace  d_i    \lor \chi_i  \mid \forall \chi_i \in \mathit{KB} \right\rbrace 
%\end{equation*}
%with $d_i := \big( \bigwedge_{j=0}^{|\mathit{Var}(\chi_i)|} z_{ij} \big)$, where $y_i, z_{ij}$ are some fresh propositional variables (including the variables in $\varphi$).  
%As a shorthand let $T_{y}:=\{ x_i \not\equiv y_i  \mid \forall x_i \in \mathit{Var}(\mathit{KB}  \cup \{\psi\})\} $ and let $T_z:=\left\lbrace  \big( \bigwedge_{j=0}^{|\mathit{Var}(\chi_i)|} z_{ij} \big)    \lor \chi_i  \mid \forall \chi_i \in \mathit{KB} \right\rbrace $ \\
%
%
%\emph{Observation 1:  $\mathit{MMod}(T_y) = \mathit{Mod}(T_y)$. } 
%
%Clearly $\mathit{MMod}(T_y) \subseteq \mathit{Mod}(T_y)$. Consider $\mathcal{M} \in \mathit{Mod}(T_y)$ assume that there exists a $\mathcal{M}' \subset \mathcal{M}$. Hence, $\exists z \in \mathcal{M}\; z \notin \mathcal{M}'$. However, w.l.o.g. assume that $z=x_i$ then $\sigma_{ \mathcal{M}'}(x_i)=0$, this requires through $x_i \neq y_i$ that $\sigma_{ \mathcal{M}'}(y_i) = 1$ and thus $y_i \in \mathcal{M}'$. 
%Clearly, $y_i \notin \mathcal{M}$. Hence, $\mathcal{M}' \not\subset \mathcal{M}$. Thus, $\mathcal{M}$ is minimal, i.e. $\mathcal{M} \in \mathit{MMod}(T_y)$ \\
%
%Observation 2: There exists a bijection $\pi$ from $\bigcup_{\mathit{KB}' \in W(\psi, \mathit{KB})} Mod(\mathit{KB}' \cup \{\varphi\})$ to $\mathit{MMod}(T)$. Where $\pi(\mathcal{M}_K)=\mathcal{M}_T$ with $\mathcal{M}_T$ being
%\begin{equation*}
%\mathcal{M}_K \cup \{y_i \mid \forall (x_i \not\equiv y_i) \in T_y \; x_i \notin \mathcal{M}_K\} \cup
% \{ z_{ij} \mid \forall (d_i \lor \chi_i) \in T_z  \forall z_{ij} \in \mathit{Var}(d_i) \; \mathcal{M}_K \nmodels \chi_i\}
%\end{equation*}
%where its inverse is simply the removal of the added elements, i.e. $ \cup \{y_i \mid \forall (x_i \not\equiv y_i) \in T_y \; x_i \notin \mathcal{M}_K\} \cup
% \{ z_{ij} \mid \forall (d_i \lor \chi_i) \in T_z  \forall z_{ij} \in \mathit{Var}(d_i) \; \mathcal{M}_K \nmodels \chi_i\}$.
%
%
%First, it has to be demonstrated that $\mathcal{M}_T$ is actually a minimal model. Let $\mathcal{M}_K$ be an arbitrary model of $\mathit{KB}' \cup \{\varphi\}$  for some $\mathit{KB}' \in W(\psi, \mathit{KB})$. Clearly, $\mathcal{M}_K \cup \{y_i \mid \forall (x_i \not\equiv y_i) \in T_y \; x_i \notin \mathcal{M}_K\}$ satisfies $T_y$. By Observation 1, it follows that it is minimal. Hence, it is from now on only relevant, if a $\chi_i$ is satisfied, and not how it is satisfied. Speaking of which, since $\mathit{KB}'$ is a maximal subset of $\mathit{KB}$ that is still consistent with $\psi$, $\mathcal{M}_K$ must satisfy a maximal amount of $\chi_i$'s, i.e. adding any additional $\chi_i$ leads to inconsistency with $\psi$. Therefore, the set $\{\chi_i \mid \forall \chi_i \in \mathit{KB} \mathcal{M}_K \models \chi_i\}$ is maximal and thereby the set $\{\chi_i \mid \forall \chi_i \in \mathit{KB}  \mathcal{M}_K \nmodels \chi_i\}$ is minimal. Hence, only a minimal amount of $d_i$'s are satisfied, i.e. $ \{ z_{ij} \mid \forall (d_i \lor \chi_i) \in T_z  \forall z_{ij} \in \mathit{Var}(d_i) \; \mathcal{M}_K \nmodels \chi_i\}$ is minimal. Since, $d_i$ is only satisfied, if $\chi_i$ is not modelled by $\mathcal{M}_K$ and vice versa, $\mathcal{M}_T$ is minimal model of $T$. \\
%
%% the case $\mathcal{M}_K \models \chi$ where $\chi \notin \mathit{KB}$, but $\chi \notin \mathit{KB}'$ can not arise. 
% 
% 
%Secondly, one has to demonstrate that $\pi$ is surjective. Assume that there exists a model $\mathcal{M}_T \in \mathit{MMod}(T)$ and that there exists no $\mathcal{M}_K \in \bigcup_{\mathit{KB}' \in W(\psi, \mathit{KB})} Mod(\mathit{KB}' \cup \{\varphi\})$ such that $\pi(\mathcal{M}_K)=\mathcal{M}_T$. Clearly, $\mathcal{M}_T$ induces an assignment $\mathcal{M}_X = \mathcal{M}_T \cap \mathit{Var}(\mathit{KB})$, i.e. $\pi^{-1}(\mathcal{M}_T)$. Since, $\mathcal{M}_T$ is minimal, either $d_i$ or $\chi_i$ is satisfied. Since, $d_i$ is more expensive it follows that, a maximal amount of $chi_i$ will be satisfied, i.e. $\mathcal{M}_T \nmodels \neg \psi$, but $(\mathcal{M}_T \cup \{ \chi_j\}) \setminus \{d_j\} \models \neg \psi$. Therefore, $\mathcal{M}_X$ satisfies a maximal amount of $\chi_i$, as their truth value only depends on the values of $x_i$'s. Thus, $\{ \chi_i \mid \forall \chi_i \in \mathit{KB} \; \mathcal{M}_K \models \chi_i \} \in W(\psi, \mathit{KB})$.\\
%
%
%Thirdly, it is clear that $\pi$ is injective. \\
%
%
%Finally, one can tackle the reduction. Let $\pi$ be the bijection from Observation 2.
%
%$" \Rightarrow "$: Assume that $\mathit{KB} \circ_G \psi \models \varphi $. Meaning that $\forall \mathit{KB}' \in W(\psi, \mathit{KB})$  and $\forall \mathcal{M}_K$ such that $\mathcal{M}_K \models \mathit{KB}' \cup \{\varphi\}$, it holds that $\mathcal{M}_K \models \varphi$. Which is precisely the domain to $\pi$. Since, $\mathcal{M}_T=\pi(\mathcal{M}_K)$ is an extension of $\mathcal{M}_K$ by variables that are not present in $\varphi$ one obtains $\mathcal{M}_T \models \varphi$. As established above $\mathcal{M}_T \in \mathit{MMod}(T)$, thus through the fact that $\pi$ is bijective one obtains $\mathit{MMod}(T)  \models \varphi$.
%
%$" \Leftarrow "$: Assume that $\mathit{MMod}(T)  \models \varphi$. Take an arbitrary model $\mathcal{M}_T \in \mathit{MMod}(T)$, since the truth value of $\varphi$ does not depend on the variables $y_i$ and $z_ij$ in the sentences $T_y$ and $T_z$ respectively, one can safely restrict the model to $\mathcal{M}_X = \mathcal{M}_T \cap \mathit{Var}(\mathit{KB})$ which is incidentally $\pi^{-1}(\mathcal{M}_T)$. Thus, $\pi^{-1}(\mathcal{M}_T) \models \varphi$. With $\mathcal{M}_T$ arbitrary and $\pi$ bijective.
%

\newpage

%######################################################################

\item[TCR.8] (10) The problem {\bf ODDSAT} is the instance of the problem on
  slide 62 for $k=1$, i.e.,

\smallskip

INSTANCE: SAT instances  $E_1$, \ldots, $E_n$,  $n\geq 1$.

\smallskip

QUESTION: Is the number of satisfiable formulas among $E_1$, \ldots
,$E_n$  (i.e., $|\,\{ E_i \mid  E_i$ is satisfiable, $1\leq i \leq n\}\,|$)
an odd number?  

\begin{enumerate}[(a)]
\item Show that  {\bf ODDSAT} $\leq^p_m$ {\bf EVENSAT}, which has
the same instances but the question is negated (i.e., the number of
satisfiable formulas $E_i$ is even)

\item Show that {\bf EVENSAT} $\leq^p_m$ {\bf CF}$_D$ by providing a
polynomial-time transformation; without
loss of generality, you may assume that satisfiability of $E_i$ implies satisfiability of $E_{i+1}$, for 
all $1\leq i < n$.
\end{enumerate}

Bonus: show that the ``without loss of generality'' assumption in
item (b) holds.

\bigskip

\emph{Solution:}\\

\begin{enumerate}[(a)]
\item Show that  {\bf ODDSAT} $\leq^p_m$ {\bf EVENSAT}, which has
the same instances but the question is negated (i.e., the number of
satisfiable formulas $E_i$ is even) \\



Consider the following transformation $\tau$ 
\begin{equation*}
\tau(E_1, \dots, E_k) = E_1, \dots, E_k, (p \lor \neg p)
\end{equation*}
where $p$ is a fresh propositional variable.

$"\Rightarrow"$: Assume that an odd number, let it be $n$, of formulas among $E_1, \dots, E_k$ is satisfied. Since, $(p \lor \neg p)$ is a tautology, it follows that $n+1$ is even. Hence, among $\tau(E_1, \dots, E_k)$ an even number of formulas is satisfied. Therefore, one can conclude that $\tau(E_1, \dots, E_k)$ is an accepted instance of \textbf{EVENSAT}.

$"\Leftarrow"$: Assume that an even number, let it be $n$, of formulas among $\tau(E_1, \dots, E_k)$ is satisfied. Since, $(p \lor \neg p)$ is a tautology, there is at least one formula satisfied. Hence, $n>0$, and due to the fact that $n$ even it follows that $n>1$. Meaning among $E_1, \dots, E_k$ there is at least one formula satisfied. With the corner case covered, the general argument is that since $n$ one obtains through $(p \lor \neg p)$ being a tautology, that $n=m+1$ with $m$ odd. Therefore, one can conclude that an odd number of formulas among $E_1, \dots, E_k$ is satisfied, i.e. they are an accepting instance of \textbf{ODDSAT}. \\



\item Show that {\bf EVENSAT} $\leq^p_m$ {\bf CF}$_D$ by providing a
polynomial-time transformation; without
loss of generality, you may assume that satisfiability of $E_i$ implies satisfiability of $E_{i+1}$, for 
all $1\leq i < n$.



Firstly, with out loss of generality, assume that $k$ is even. This can be done since one can simply add an unsatisfiable formula at the beginning of all formulas and shift the index, e.g. $E_1, \dots, E_k$ with $k$ odd, to $ E_1', \dots, E_{k+1}'= (p \land \neg p),  E_1, \dots, E_k$.

Secondly, without loss of generality, assume that the variables of each formula are pairwise disjoint, i.e. $\forall i, j \in \{1, \dots, k\} \; i \neq j \Rightarrow \mathit{Var}(E_i) \cap \mathit{Var}(E_j)=\emptyset$.



Consider the following transformation $\tau(E_1, \dots, E_k)=(T, \psi, \varphi)$ where $(T, \psi, \varphi)$ is an input instance for $T \circ_D \psi \models \varphi$ and where 
\begin{equation*}
\begin{split}
T &:= \{c_1, \dots, c_k\} \\
\psi &:= \bigwedge_{i \in \{1, \dots, k\}} c_i \to E_i \\
\varphi &:=   c_1 \lor \big(\bigvee_{i \in \{1, \dots , \frac{k}{2}-1\}} (\neg c_{2i}   \land  c_{2i+1} )\big)   \lor \neg c_k 
\end{split}
\end{equation*}
Firstly, this transformation only increases the input in a linear manner with respect to the number of clauses. Thus this transformation can be done in polynomial time.
% \land \bigwedge_{i \in \{1, \dots, k-1\}} (c_i \to c_{i+1})

$"\Rightarrow"$: Assume that an even number, let it be $n$, of formulas among $E_1, \dots, E_k$ is satisfied. \emph{Case 1}, all formulas are satisfied. As established in the lecture all models in $\mathit{Mod}(T \circ_D \psi)$ satisfy the maximum number of $c_i$'s. In this case all of them must be satisfied. Hence, under all models $c_1$ and thus $\varphi$ is satisfied.
% With all formulas satisfied, $c_1$ and all $i<k$, $(c_i \to c_{i+1})$ are satisfied.
 \emph{Case 2}, no formula is satisfied. In this case no $c_i$ is satisfied, i.e. the only model of $\psi$ is the one that is empty. Hence, said model is the only one of $T \circ_D \psi$, indecently this satisfies $\neg c_k$ and thus also $\varphi$.
% , and all $(c_i \to c_{i+1})$ for $i<k$ hold vacuously.
\emph{Otherwise}, there exists at least one formula that is not satisfied and at least one that is. Hence, given the input restriction, there exists an $m$ such that $E_{m}$ is not satisfied and $E_{m+1}$ is satisfied. 
Every model $\mathcal{M} \in \mathit{Mod}(T \circ_D \psi)$ $\mathcal{M}$, deviates as little as possible from the single model $\{c_1, \dots, c_k\} $ of $T$. Hence, it maximises the number of $c_i$'s it contains. However, $c_i$ can only be satisfied if $E_i$ is. Now, knowing that all $E_i$ with $i \leq m$ are not satisfiable, the corresponding $c_i$ can not be part of the model. Therefore, it follows for every model $\mathcal{M} \in \mathit{Mod}(T \circ_D \psi)$ $\mathcal{M}$ $\mathcal{M} \models \neg c_i$ for $i \leq m$ and  $\mathcal{M} \models  c_i$ for $i>m$. Meaning that $m$ is the same in all models and must be even, i.e. $m = 2j$.  Thus  $\neg c_{2i}   \land  c_{2i+1} $ is satisfied in all models. Thus one obtains $T \circ_D \psi \models \varphi$.

%
%As established in the lecture every model $\mathcal{M} \in \mathit{Mod}(T \circ_D \psi)$ $\mathcal{M}$ satisfies the maximal amount of $E_i$'s. Now, since $c_i$ can only be 
%Every model in  deviates only minimally from the models of 
%
%Since, $\mathcal{M} \in \mathit{Mod}(T \circ_D \psi)$ $\mathcal{M}$ satisfies a maximal amount of $c_i$'s, one can conclude that no further $c_i$ can be satisfied. Hence, the number of $c_i$ satisfied is maximal, therefore even. Moreover, no model in  $ \mathit{Mod}(T \circ_D \psi)$ can satisfy any smaller then $m+1$, as otherwise the input restriction is violated, this forces that in all model in $ \mathit{Mod}(T \circ_D \psi)$ it must be the case that for every $m < i \leq k$ $c_i$ is satisfied. Meaning that $m$ is the same in all models and must be even, i.e. $m = 2j$.  Thus  $\neg c_{2i}   \land  c_{2i+1} $ is satisfied in all models. 
%%Moreover, since for every $m < i \leq k$ $c_i$ is satisfied by assumption, it follows that all $i<k$, $(c_i \to c_{i+1})$ are satisfied in all models as well. 
%Thus one obtains $T \circ_D \psi \models \varphi$.



$"\Leftarrow"$:  Assume that an odd number, let it be $n$, of formulas among $E_1, \dots, E_k$ is satisfied. Given the assumptions made above, neither the case where all formulas nor the case were no formula is satisfied apply have to be considered. Hence, there exists at least one formula that is not satisfied and at least one that is. Hence, given the input restriction, there exists an $m$ such that $E_{m}$ is not satisfied and $E_{m+1}$ is satisfied. Clearly, this $m$ is odd, i.e. $m = 2j+1$ for some $j$. Moreover, given the input restriction it is known that for all $i \leq m$ $E_i$ is unsatisfiable and that for all $m < i \leq k$ $E_i$ is satisfiable. Since, every model $\mathit{Mod}(T \circ_D \psi)$ maximises the number of $c_i$'s, it follows that for all $i \leq m$ $c_i$ evaluates to $0$ and that for all $m < i \leq k$ $c_i$ evaluates to $1$ in every model. Hence, in every model of  $\mathit{Mod}(T \circ_D \psi)$, the transition from unsatisfied formulas to satisfied formulas occurs on $c_{2j+1}$ and $c_{2 \cdot (j+1)}$. Hence, no model can satisfy $  c_1 \lor \big(\bigvee_{i \in \{1, \dots , \frac{k}{2}-1\}} (\neg c_{2i}   \land  c_{2i+1} )\big)   \lor \neg c_k $. Therefore, $T \circ_D \psi \nmodels \varphi$.


\item Bonus: show that the ``without loss of generality'' assumption in
item (b) holds.

Here unfortunately an somewhat indirect answer. Meaning that by giving an algorithm that establishes $\Delta^P_2[O(log)]$-membership of the unrestricted case, then using the fact that the restricted case is $\Delta^P_2[O(log)]$-complete to show completeness of the general case and thereby establish that those problems can be used interchangeably. Hence, consider the following algorithm

\texttt{
\begin{tabbing}
EVE\=NSAT($(E_1,\dots ,E_k)$): \\
\> $Q:= (\lambda x_1 \dots \lambda x_k (\text{SAT}(x_i))_{i \in \{1, \dots, k\}})$   // (1) \\
\> $Q_a := Q\; (E_1,\dots E_k)$ // (2) \\
\> if \=$\sum_{a_i \in Q_a} a_i$ is even: \\
\>\> return True \\
\> else: \\
\>\> return False
\end{tabbing}}

In step (1) $k$ independent queries to a \textbf{SAT}-oracle, returning $1$ if the instance is satisfiable and $0$ otherwise, are set up.
Then, those prepared queries are executed in parallel on the formulas $ (E_1,\dots ,E_k)$.  With a linear amount of parallel oracle calls and with all remaining steps being done in linear time as well, this algorithm establishes  $\mathbf{P_{||}^{NP}}$-membership. However, since this class coincides with the class $\Delta^P_2[O(log)]$ the membership can be transferred. Now knowing that the restricted case is $\Delta^P_2[O(log)]$-complete, completeness of the general case follows in suit. Hence, there must exist a reduction of the form $\textbf{EVENSAT}_G \leq^p_m \textbf{EVENSAT}_R$, i.e. general to restricted case. Hence, the reduction in the previous exercise suffices.
\end{enumerate}




\end{enumerate}

%
%
%Note: Please leave the text of the exercises you work out in, 
%and delete the text of the others. Always write the label of the exercise you 
%select to make identification easier; e.g., for CT.2, change ``$\backslash$item ``
%to ``$\backslash$item[CT.2]'') and manually delete all other exercises.
%
%\section{Complexity Theory}
%\label{sec:complexity}
%
%\begin{enumerate}[CT.1]
%
%
%\newpage
%
%\item (10) Examine whether the following restricted versions of SAT  are tractable.
%  
%  \begin{itemize}
%
%  \item {\bf Not-All-Equal SAT, NAESAT}: The input formula $F$ is a
%        CNF, and the question is whether $F$ can be satisfied 
%        by some assignment $\sigma$ to the variables such that in no clause of $F$ 
%        all literals are true.
%        
%        Example: $F = (x_1 \lor x_2 ) \land (x_2 \lor \neg x_3)$; take e.g. $\sigma(x_1)=1$, $\sigma(x_2)=0$, $\sigma(x_3)=0$.  \\
%        
%        
%        
%This problem is not-tractable, in fact it is \NP-hard. To support this claim a polynomial reduction from \textbf{CNF} to \textbf{NAESAT} will be given. Let $\varphi$ be a \textbf{CNF} instance, i.e. a formula in CNF. Consider the following translation.  
%        
%\item  {\bf Read-$2$ SAT}: The input formula $F$ is a CNF, and each
%        variable occurs only at most $2$ times in $F$.
%        
%
% \item {\bf All-Resolve-SAT}:  The input formula $F$ is a  CNF, and
% each pair of distinct clauses $c$ and $c'$ of $F$ resolves, i.e.,
% there is a variable $x$ such that $c = x \lor \alpha$ and $c' = \neg
% x\lor   \beta$ or the other way round ($c = \neg x \lor \alpha$ and
% $c' = x\lor \beta$)
%
% Examples:  $F=x\land \neg x$;  $G = (x \lor y) \land (\neg x \lor z)
% \land (\neg z \lor \neg y)$
%
%\end{itemize}
%
%Bonus: determine whether {\bf Read-$k$ SAT}, where $k>1$ is fixed, is
%tractable, for each $k$.
%
%
%
%  \begin{itemize}
%
%  \item {\bf Not-All-Equal SAT, NAESAT}: The input formula $F$ is a
%        CNF, and the question is whether $F$ can be satisfied 
%        by some assignment $\sigma$ to the variables such that in no clause of $F$ 
%        all literals are true.
%        
%        Example: $F = (x_1 \lor x_2 ) \land (x_2 \lor \neg x_3)$; take e.g. $\sigma(x_1)=1$, $\sigma(x_2)=0$, $\sigma(x_3)=0$.  \\
%        
%        
%        
%This problem is not-tractable, in fact it is \NP-hard. To support this claim a polynomial reduction from \textbf{CNF} to \textbf{NAESAT} will be given. Let $\varphi$ be a \textbf{CNF} instance, i.e. a formula in CNF. Consider the following translation.  
%
%Let $t$ and $f$ be two new propositional variables, let $\varphi:= (p_{11} \lor \dots \lor p_{1n_1}) \land \dots  \land (p_{m1} \lor \dots \lor p_{mn_m})  $ be a formula in CNF with $p_ij$ being a literal. Let $l_{i1} , \dots , l_{in_i}, l'_{i1} , \dots , l'_{in_i}$ be literals for $i \in \{1, \dots m\}$ and let $\tau$ be the following transformation
%%\begin{equation*}
%%\begin{split}
%%\tau(\varphi) := &(x_{11} \lor \dots \lor x'_{1n_1} \lor t) \land  (x'_{11} \lor \dots \lor x'_{1n_1}, \lor f) \\
%%& \land \dots  \land  \\
%%& (x_{m1} \lor \dots \lor x_{mn_m} \lor t) \land (x_{m1} \lor \dots \lor x_{mn_m} \lor f) \land (t \lor f)
%%\end{split}
%%\end{equation*}
%%or more concisely 
%\begin{equation*}
%\begin{split}
%\tau(\varphi) := (t \lor f) \land  \bigwedge_{i =1}^{m}  (l'_{i1} \lor \dots \lor l'_{in_i} \lor t)  \land \bigwedge_{i =1}^{m}    (l_{i1} \lor \dots \lor l_{in_i}, \lor f) \\
%\end{split}
%\end{equation*}
%such that $l_{ij}:=p_{ij}[x_k/y_k]$ and $l'_{ij}:=p_{ij}[x_k/y'_k]$, with $x_k \in Var(\varphi)$ and $y_k, y'_k$ been a variable introduced in $Var(\tau(\varphi))$.
%That is, using $\varphi$ we simply build two copies $\varphi_t$ and $\varphi_f$ of $\varphi$ where each copy has its own set of variables and each clause in the prior is extended by the variable $t$ and each in the latter by $f$.
%
%
%What remains to show is that $\chi_{\textbf{CNF}}(\varphi) = 1$ if and only if $\chi_{\textbf{NAESAT}}(\tau(\varphi)) = 1$. \\
%
%"$\Rightarrow$:" Assume that $\chi_{\textbf{CNF}}(\varphi) = 1$, meaning that $\varphi$ is in CNF and has an satisfying assignment $\sigma$. Let $\sigma_{\tau}$ be the truth assignment for $\tau(\varphi)$, which shall be constructed based on the assignment $\sigma$. 
%Firstly,  since $\varphi_f$ is merely a copy of $\varphi$, which clauses are extended by $f$. Hence, let $\sigma_{\tau}(y_k)=\sigma(x_k)$. Since, $\sigma$ is a satisfying assignment at least one literal in each clause is  satisfied. Moreover, let $\sigma_{\tau}(f)=0$, thus it follows that every clause in $\varphi_f$ has one literal that evaluates to $1$  and one that evaluates to $0$ under $\sigma_{\tau}$. Now, since $(t \lor f)$ and $\sigma_{\tau}(f)=0$ it follows that $\sigma_{\tau}(t)=1$. Hence, every clause in $\varphi_t$ is now satisfied. Hence, forall $y'_k$ let $\sigma_{\tau}(y'_k)=0$. Hence, there again exists a literal evaluating to $1$ and a literal evaluation to $0$ in each clause of $\varphi_t$.
%A satisfying assignment for the problem $\textbf{NAESAT}$ is found, and thus $\chi_{\textbf{CNF}}(\tau(\varphi)) = 1$.
%
%"$\Leftarrow$": Assume that $\chi_{\textbf{CNF}}(\tau(\varphi)) = 1$, meaning that there exists an satisfying assignment $\sigma_{\tau}$ such that not all literals are true. That is, either $\sigma_{\tau}(t)=1$ or $\sigma_{\tau}(f)=1$. Without loss of generality assume the prior. 
%Implying that  $\sigma_{\tau}(f)=0$. However, $\varphi_f$ is satisfied under $\sigma_{\tau}$, thus for each clause $C_i$ in $\varphi_f$ there must be a literal $l_ij \neq f$ that is satisfied under $\sigma_{\tau}$. Now, given the fact that $\varphi_f$ is a copy of $\varphi$ with every clause being extended by $f$ and the fact that $\sigma_{\tau}(f)=0$ it follows that $\sigma(x_k)=\sigma_{\tau}(y_k)$ is a satisfying assignment of $\varphi$. Resulting in $\chi_{\textbf{CNF}}(\varphi) = 1$.
%
%
%Clearly, if this is the $\psi_f$ is satisfied, without assigning $f$ to true. Meaning that for $\psi_f$ there exists an assignment that satisfies every clause, which can only be the case if in each clause, there exists at least one literal that evaluates to true.
%        
%\item  {\bf Read-$2$ SAT}: The input formula $F$ is a CNF, and each
%        variable occurs only at most $2$ times in $F$.
%
%This variant is tractable. To show this statement, let $\varphi$ be a CNF-formula, where every variable occurs at most twice.
%Now consider the following algorithm.
%
%
%\texttt{
%\begin{tabbing}
%Read\=-2-SAT($\varphi$): \\
%\> $\Gamma:= \mathit{Cl}(\varphi)$\\
%\> wh\=ile $\Gamma \neq \emptyset$:\\
%\>\> if \=$\exists C , C' \in \Gamma \; C=(x) \land C'=(\neg x)$: // (0) \\
%\>\>\> return False \\
%\>\> $\Gamma' := \emptyset$:\\
%\>\> while $\Gamma \neq \Gamma'$:  //  (1)\\
%\>\>\> $\Gamma := \Gamma'$\\
%\>\>\> $\Gamma' :=$ remove\_tautological\_clauses($\Gamma $) // (1.1) \\
%\>\>\>  $\Gamma' :=$ remove\_clauses\_with\_monotone\_variables($\Gamma $)  // (1.2)\\
%\>\> $C := $ choose\_random\_clause($\Gamma$)\\
%\>\> for  $C' \in \Gamma$:  // (2)\\
%\>\>\> if \= $C=(l \lor \alpha)$ and  $C'=(\overline{l} \lor \beta)$ // (2.1) \\
%\>\>\>\> $C_n := (\alpha \lor \beta)$\\
%\>\>\>\> $\Gamma:= (\Gamma \setminus \{C, C'\}) \cup \{C_n\}$\\
%\>\>\>\> break  // exit for loop\\
%\> return True\\
%\end{tabbing}}
%
%
%
%(0) If there are two complementary unit clauses, there can not be an assignment satisfying the formula.
%
%(1.1) A variable is monotone if it only occurs either positively or negatively. Hence, one can safely satisfy the all clauses in which this variable occurs by simply choosing an assignment corresponding to the polarity of the occurrence, i.e. if $x$ is negative monotone then choose $\sigma$ such that $\sigma(x)=0$ and vice verse. This choice can not lead to another clause being no longer satisfiable. Hence, this step preserves satisfiability.
%
%(1.2) A clause is tautological if it has the form $(x \lor \neg x \lor \alpha)$, because any assignment satisfies this clause. Hence, they can be removed safely as well, i.e. removing this clause preserves satisfiability.
%
%Hence, after (1) $\Gamma$ exhibits the following properties.   
%\begin{itemize}
%\item \emph{No clause occurs twice. }
%
%
%If they would the variables within must be monotone and can contain a variable twice, thus those clauses were removed in step (1.1).
%
%\item \emph{Every clause contains two or more variables. }
%
%Every unit clause must contain a monotone variable, see step (0). Hence, all unit clauses are removed in (1.1).
%If they contain the same variable twice, then they must appear as complementary literals. Otherwise, they were removed in step (1.1). However, in that case this cause is tautological. Meaning it was removed in step (1.2).
%
%
%\item\emph{ Every variable occurs once as positive literal and once as negative literal in two different clauses.}
%
%Otherwise those variables are monotone and were removed in step (1.1) or they would be part of a tautological clause.
%\end{itemize}
%The whole step (1) can be done in polynomial time. Firstly, the number of iterations in the while loop is clearly bounded by the number of clauses in $\Gamma$, i.e. clauses are removed until it is no longer possible. Secondly, (1.1) runs in polynomial time as well, i.e. for each variable run through every clause, if it is present in said clause save the polarity of its occurrences and compare the two values for monotonicity. Thirdly, running through all clauses and checking if they contain complementary literals is also polynomial wrt. to the input.
%Lastly,  with every step preserving satisfiability $\Gamma$ after (1) is satisfiable if and only if $\Gamma$ before (1) is satisfiable. \\
%
%
%\emph{Observation 1: Let $C=(x \lor \alpha)$ and $C'=(\neg x \lor \beta)$ where $\alpha$ and $\beta$ are some disjunction of literals not containing $x$ or $\neg x$. Then $\{C,C'\}$ is satisfiable if and only if $\{(\alpha \lor \beta)\}$ is satisfiable.}
%
%$"\Rightarrow"$: $\{C,C'\}$ is satisfiable. Therefore, either $\alpha$ or $\beta$ has to be satisfied, i.e. $x$ and $\neg x$ can not both be true. Hence, any assignment $\sigma$ satisfying $\{C,C'\}$ must also satisfy $\{(\alpha \lor \beta)\}$.
%$"\Leftarrow"$:  $\{(\alpha \lor \beta)\}$ is satisfiable. Hence, for every assignment $\sigma$ either $\alpha$ or $\beta$ is satisfied. If $\alpha$ is satisfied under $\sigma$, then $C$ is satisfied, without relying on the truth assignment of $x$. Hence, $\sigma$ can be extended by the assignment $\{x \mapsto 0\}$ in order to satisfy $C'$. Analogue for the other case. \\
%
%As for step (2). Choosing a clause $C=(l \lor \alpha)$ at random, due to (0) and (1) one knows that there must be a clause $C'=(\overline{l} \lor \beta)$, different from $C$ in $\Gamma$ containing the complement of the literal $l$, i.e. $\overline{l}$. W.l.o.g. let $l=x$. After the respective clause is found, the next step (2.1) is basically a resolution step. From Observation 1 it follows that $\Gamma$ is satisfiable if and only if $(\Gamma \setminus \{C, C'\}) \cup \{(\alpha \lor \beta)\}$ is satisfiable. Moreover, since each variable occurs twice, step (2.1) eliminates all occurrences of $x$. Moreover, since every clause must contain at least two variables this step can not result in the empty clause. Hence, resulting set is an instance of the problem {\bf Read-$2$ SAT} that is satisfiable, if and only of the original instance was satisfiable. However, the only difference is this instance is shorter by at least one variable. Therefore, the whole proceeder is linearly bounded by the number of variables in $\varphi$.
%
%
%
%
%%
%%
%%
%%Let $\varphi$ be an input formula for the {\bf Read-$2$ SAT} problem. Consider the following algorithm.
%%\begin{enumerate}[1.]
%%\item Remove all clauses $C \in \mathcal{C}(\varphi)$ of the form $C=(x \lor \neg x \lor l_1 \lor \dots \lor l_n)$ for some $x \in Var(\varphi)$, and some $l_1, \dots, l_n \in Lit(\varphi)$. Set $\sigma(x)=1$.
%%\item For each $x \in Var(\varphi)$ check, 
%%\begin{enumerate}
%%\item if  $\neg x \notin Lit(C)$, remove all $C$ where $x \in Var(C)$ and set $\sigma(x)=1$;
%%\item if  $x \notin Lit(C)$, remove all $C$ where $x \in Var(C)$ and set $\sigma(x)=0$;
%%\end{enumerate}
%%\item If all clauses are removed, return satisfiable.
%%\item If there exists a unit clause of the form $C:=( x )$ and a unit clause of the form $C:=( \neg x )$ for some $x \in Var(\varphi)$, return unsatisfiable.
%%\item If there exists a unit clause of the form $C:=(p )$ for some literal $p$: 
%%\begin{enumerate}
%%\item If $p = x$ for some $x \in Var(\varphi)$ let $\sigma(x)=1$;
%%\item If $p= \neg x$ for some $x \in Var(\varphi)$ let $\sigma(x)=0$;
%%\item Remove all $C$ where $x \in C$.
%%\item If there exists a $C'=( \overline{p}  \lor l_1 \lor \dots \lor l_n)$ remove $C'$ and add $C'':=(  l_1 \lor \dots \lor l_n)$.
%%\end{enumerate}
%%\item Else: Select a non-assigned variable $x \in Var(\varphi)$ and set $\sigma(x)=1$.
%%\begin{enumerate}
%%\item Remove all $C$ where $x \in C$.
%%\item If there exists a $C'=(\neg x  \lor l_1 \lor \dots \lor l_n)$ remove $C'$ and add $C'':=(  l_1 \lor \dots \lor l_n)$.
%%\end{enumerate}
%%\item Jump to 2.
%%\end{enumerate} 
%%        
%%First it has to be argued that the algorithm sketched above exhibits the desired behaviour. 
%%\begin{itemize}
%%\item Step 1: As there are at most two occurrences of $x$. If both $x$ and $\neg x$ occur in the same clause, they can not be part of any other clause. Hence, the assignment of $x$ does not influence the truth values of the other clauses. Since, one can choose the assignment of $x$ arbitrarily $x$ will be set to true.
%%\item Step 2. Due to the fact that if a variable $x$ occurs only as positive literal in clauses, setting this variable to true only satisfies the clauses in question and does not influence any other clause (because, those clauses are the only one that include $x$).
%%Similarly for negative monotone literals.
%%\item Step 3: If after steps 1. and 2. all clauses are remove, all clauses have been satisfied by the current $\sigma$ and the remaining variables can be chosen arbitrarily.
%%\item Step 4: If there are two contradicting unit clauses they must have been present in $\varphi$ as well. This is due to the fact that up until now clauses were only removed and not reduced (in size). Hence, regardless of assignment the formula will be unsatisfiable.
%%\item Step 5: If there exists a unit clause of the form $C:=(p)$, then the only possible satisfying assignment must be one that satisfies the literal $p$. If this is the case, it is known that there must exist a non-unit clause $C'$ that contains the complement of $p$. Otherwise, $C$ would have been removed in step 2. Similarly, there can not be a unit clause of the form $(\overline{p})$ present. Otherwise, unsatisfiablility would have been reported in step 5. 
%%\item Step 6: If there does not exists a unit clause, simply pretend there exists one of the form $(x)$ for some random variable $x$. Proceed as in the previous step. 
%%\end{itemize}
%%
%%Firstly, Step 2 ensures that after its application every variable occurs once as positive literal and once as negative literal, with the preprocessing step (Step 1) ensuring that those occurrences are not in the same clause.   Hence, in every iteration of the 
%%        
%%        
%%First some preprocessing. Consider the following transformation $\rho$
%%\begin{enumerate}[1.]
%%
%%\item \emph{Are there contradicting unit clauses.}\\
%%
%%Unit clauses have deterministic assignment. That is, if the clause has the form $x$ then it must be that $\sigma(x)=1$, on the other hand, if the clause has the form $\neg x$ then it must be that $\sigma(x)=0$. \\
%%
%%\emph{Complexity:} This step is linear wrt. to the number of clauses, as one only has to iterate over all clauses and check if the current clause is unit.\\
%%
%%\item \emph{Remove all unit clauses.}\\
%%
%%Unit clauses have deterministic assignment. That is, if the clause has the form $x$ then it must be that $\sigma(x)=1$, on the other hand, if the clause has the form $\neg x$ then it must be that $\sigma(x)=0$. \\
%%
%%\emph{Complexity:} This step is linear wrt. to the number of clauses, as one only has to iterate over all clauses and check if the current clause is unit.\\
%%
%%
%%\item \emph{If there is a clause that contains the literal $x$ and $\neg x$, then this clause can be removed safely. } \\
%%
%%This clause is satisfied under any assignment. Moreover, since $x$ can only occur twice, the assignment of $x$ does not influence the truth value of any other clause. Hence, $\sigma(x)$ can be chosen at random without consequences. \\
%%
%%\emph{Complexity:} This step is linear wrt. to the number of literals. That is, one iterates over all clauses. For each clause one then iterates over all its literals. If one encounters $x$ and $\neg x$ during the inner loop. Simply remove the clause. \\
%%
%%\item \emph{If a variable occurs only positively, i.e. for a variable $x$ the literal $\neg x$ does not occur in $\varphi$, all clauses containing $x$ can be removed. } \\
%%
%%That is, assigning $\sigma(x)=1$ can not prevent a clause from being satisfied, as $\neg x$ is absent.\\
%%
%%\emph{Complexity:} For each variable $x$, iterate over the clauses. If $x$ is in said clause store whether $x$ occurs positively or negatively as well as the clause in question. After all clauses have been searched, check if $x$ occurs negatively in one of the at most two clauses. If this is the not the case remove those clauses. This step runs at most in number of variables times number of clauses.  \\
%%
%%
%%\item \emph{If a variable occurs only negatively, i.e. for a variable $x$ the literal $x$ does not occur in $\varphi$, all clauses containing $\neg x$ can be removed. }\\
%%
%%That is, assigning $\sigma(x)=0$ can not prevent a clause from being satisfied, as $x$ is absent. \\
%%
%%\emph{Complexity:} For each variable $x$, iterate over the clauses. If $x$ is in said clause store whether $x$ occurs positively or negatively as well as the clause in question. After all clauses have been searched, check if $x$ occurs negatively in one of the at most two clauses. If this is the not the case remove those clauses. This step runs at most in number of variables times number of clauses.  \\
%%
%%
%%\end{enumerate}
%%
%%To summarise every clause in $\rho(\varphi)$ contains at least two distinct variables. Moreover, every variable in $\rho(\varphi)$  occurs exactly once in a positive literal and exactly once in a negative literal. Any single variable would have been removed during steps (5. and 6.).
%%
%%From here the following proceeder can be created.
%%\begin{enumerate}[1.]
%%\item \emph{Compute $\rho(\varphi)$}\\
%%\item \emph{Choose an arbitrary variable $x$ and set $\sigma(x)=1$.}\\
%%
%%Observe that since $x$ occurs exactly twice, the clause $(x \lor l_1 \lor \dots \lor l_n)$ is satisfied and can be removed. Moreover, the clause 
%%$(\neg x \lor p_1 \lor \dots \lor p_n)$ which exists can then be shortened to $(p_1 \lor \dots \lor p_n)$.  Hence, the resulting formula does not contain an instance on $x$. Furthermore, the resulting formula has at least one monotone (i.e. a single positive or a single negative) occurring variable $y$. This is, due to the fact that $\rho(\varphi)$ guarantees that $x$ must occur with at least another distinct variable in its clause. 
%%
%%\item \emph{Repeat 1. and 2. until every variable is assigned.}\\
%%
%%Assume that the resulting assignment $\sigma$ does not satisfy $\varphi$.
%%Hence, there are two clauses that are not satisfiable. 
%%\end{enumerate}
%
%%                                
%%\texttt{
%%\begin{tabbing}
%%$\mathcal{A}$ (\=$\varphi$):  \\
%%\> $\mathcal{C}':= {}$  //  Empty set\\
%%\> $A:= [(0,Null, Null) \mid x \in Var(\varphi)]$  \\
%%\> //  Array indexed by variables\\
%%\> // (e.g. based on enumeration of variables). \\ 
%%\\
%%\> for \=$C \in \mathcal{C}(\varphi)$: 	  //  Set of clauses of $\varphi$ \\
%%\>\> If \= $\neg (x \in Lit(C) \land  \neg x \in Lit(C))$: //  Literals of clause \\
%%\>\>\>  $\mathcal{C}' := \mathcal{C}' \cup \{C\}$ \\ 
%%\\
%%\> for \=$C \in \mathcal{C}'$: 	 \\
%%\>\> If $x \in Lit(C)$:\\
%%\>\>\>  $A[x][0] := A[x][0]  + 1 $ \\
%%\>\>\>  $A[x][1] := C $ \\
%%\>\> If $\neg x \in Lit(C)$:\\
%%\>\>\>  $A[x][0] := A[x][0]  - 1 $ \\
%%\>\>\>  $A[x][2] := C $ \\
%%\\
%%\> $\mathcal{C}:= {}$  //  Empty set\\
%%\> for $x \in Var(\varphi):$ \\
%%\>\> If $A[x][0] = 0$:\\
%%\>\>\> $\mathcal{C}:= \mathcal{C} \cup \{A[x][1]\}  \cup \{A[x][2]\}$\\
%%\end{tabbing}}
%%
%
%
%
%
%
% \item {\bf All-Resolve-SAT}:  The input formula $F$ is a  CNF, and
% each pair of distinct clauses $c$ and $c'$ of $F$ resolves, i.e.,
% there is a variable $x$ such that $c = x \lor \alpha$ and $c' = \neg
% x\lor   \beta$ or the other way round ($c = \neg x \lor \alpha$ and
% $c' = x\lor \beta$)
%
% Examples:  $F=x\land \neg x$;  $G = (x \lor y) \land (\neg x \lor z)
% \land (\neg z \lor \neg y)$
% 
% 
% 
%\emph{Observation 1: Consider a set of clauses $\Gamma$ over $m$ variables, such that each $C \in \Gamma$ contains $m$ unique variables, i.e. $|\mathit{Var}(C)|=m$. $\Gamma$ is satisfiable if and only if $|\Gamma|<2^m$, i.e. if there are strictly less than $2^m$ unique clauses in $\Gamma$. }
%
%Firstly, there can be at most $2^m$ unique clauses. That is, with every clause having $m$ unique variables it follows that $\mathit{Var}(\Gamma)=\mathit{Var}(C)$ for each $C$. Now since every variable can occur either positively or negatively there are $2^m$ combinations, and thus $2^m$ clauses. 
%Secondly, clearly if $|\Gamma|=2^m$ $\Gamma$ is unsatisfiable. That is, for each clause $C \in \Gamma$ there exists a clause $\overline{C} \in \Gamma$ where for every literal in $C$, there exists its complement in $\overline{C}$.
%
%
%Thirdly, consider the case $|\Gamma|<2^m$. Hence, there exists a clause $C \in\Gamma$ which does not have a complement $\overline{C} \in \Gamma$. Consider the assignment $\sigma_{C}$ induced by $C$, i.e. $\sigma_{C}(x)=1$ iff $x$ is a positive literal in $C$. Assume that there exist a clause $C' \in \Gamma$ such that $C'$ is not satisfied under $\sigma_C$. This would imply that for every positive literal of $C$, $C'$ contains its negative counterpart. Analogue for the negative literals in $C$. However, this would mean that $C'$ is actually $\overline{C}$, which clearly is impossible. \\
%
%
%\emph{Observation 2: Let $C$ be a clause and let $x$ be a new variable not contained in $C$. $C$ is equivalent to $\{C \lor x , C\lor \neg x\}$. }
%
%Clearly, any model satisfying $C$ satisfies $C \lor x $ and $C\lor \neg x$. On the other hand any model satisfying $C \lor x $ and $C \lor \neg x$ must satisfy $C$, as no model can satisfy $x$ and $\neg x$ at the same time.\\
%
%Let $\mathcal{E}_x(\Gamma)= \bigcup_{C \in \Gamma} \{C \lor x , C\lor \neg x\}$ for some set of clauses $\Gamma$. As syntactic sugar let $\mathcal{E}_x(C)=\mathcal{E}_x(\{C\})$. Moreover, let $\mathcal{E}_V(C)$ be the set of clauses computed by applying the above extension presented in Observation 2 until every clause in the resulting set contains all variables in $V$. That is,
%\begin{equation*}
%\begin{split}
%\mathcal{E}_{\emptyset}(\Gamma) &= \Gamma \\
%\mathcal{E}_V(\Gamma) &= \mathcal{E}_x(\mathcal{E}_{V \setminus \{x\}}(\Gamma)) \quad \text{for some } x \notin \mathit{Var}(\Gamma) \text{ and } x \in \mathit{V}
%\end{split}
%\end{equation*}
%
%\emph{Observation 3:  Let $V$ be a set of variables, s.t. $|V|=m$. Let $\Gamma$ be a set of clauses over $V$ and let $C \in \Gamma$ such that $|\mathit{Var}(C)|=n$ (unique variables) then $|\mathcal{E}_V(C)|=2^{m-n}$.}
%
%For a clause with $n$ distinct variables applying $\mathcal{E}_V$ for $|V|=m$, will result $m-n$ applications of $\mathcal{E}_x$. At each iteration the input set is doubled, i.e. every clause in the input set is replaced by two clauses. Therefore, since starting with a clause set of size one, one obtains $2^{m-n}$ clauses in the final set.  \\
%
%
%
%\emph{Observation 4: Let $\Gamma$ be a set of unique clauses with out duplicate variables over the set of variables $V$, where $\forall C, C' \in \Gamma$ $C$ and $C'$ resolve. Then $\forall C, C' \in \Gamma \; C \neq C' \Rightarrow \mathcal{E}_V(C) \cap \mathcal{E}_V(C') = \emptyset$}
%
%
%Assume that there are two distinct clauses $C$ and $C'$ in $\Gamma$ such that $ \mathcal{E}_V(C) \cap \mathcal{E}_V(C') \neq \emptyset$. Hence, $D \in  \mathcal{E}_V(C) \cap \mathcal{E}_V(C')$ exists. It is known that there exists a variable $x  \mathit{Var}(C) \cap  \mathit{Var}(C')$ such that, w.l.o.g., $x \in \mathit{Lit}(C)$ and $\neg x \in \mathit{Lit}(C')$. Since the operator $\mathcal{E}_V$ produces only clauses that are extensions of the original clauses. Moreover, in each of those extensions, a variable occurs only once. Hence, $\forall C_e \in \mathit{Var}(C) \; x  \in \mathit{Lit}(C_e)$ and $\forall C_e' \in \mathit{Var}(C') \; \neg x  \in \mathit{Lit}(C_e')$. Thus, forcing the conclusion that $D$ can not exist. \\
%
%
%\emph{Observation 5: Let $\Gamma$ be a set of unique clauses without duplicate variables over the set of variables $V$, where $\forall C, C' \in \Gamma$ $C$ and $C'$ resolve. Then $\Gamma$ is satisfiable if and only if $\sum_{C \in \Gamma} | \mathcal{E}_V(C)|<2^{|V|}$.}
%
%By assumption, all clauses in $\Gamma$ are unique and resolve pairwise, while having no duplicate variables. Hence, by Observation 4, it follows that $|\bigcup_{C \in \Gamma} \mathcal{E}_V(C)|= \sum_{C \in \Gamma} | \mathcal{E}_V(C)|$. Now, by Observation 1, one knows that $\mathcal{E}_V(\Gamma)$ is satisfiable if and only if $|\mathcal{E}_V(\Gamma)|< 2^{|V|}$. Lastly, from Observation 2 it is known that $\mathcal{E}_V$ preserves validity. Therefore, $\mathcal{E}_V(\Gamma)$ is satisfiable if $\Gamma$ is satisfiable. Resulting in the conclusion that $\Gamma$ is satisfiable. \\
%
%
%\emph{Observation 6: Let $\Gamma$ be a set of clauses over the set of variables $V$, where $\forall C, C' \in \Gamma$ $C$ and $C'$ resolve. Then $\Gamma$ testing satisfiability can be done in quadratic (probably linear) time wrt. to the combined length of the clauses in $\Gamma$.}
%
%Firstly, iterate over all clauses and check if they contain duplicate variables, If so remove all duplicates. This operation is clearly save.
%Secondly, iterate over all clauses and check for duplicates. Both operations can be done in linear time. The resulting $\Gamma'$ is now a pairwise resolving set of unique clauses without duplicate variables over the set of variables $V$
%By Observation 5 it is known that $\Gamma'$ is satisfiable if and only if $\sum_{C \in \Gamma} | \mathcal{E}_V(C)|<2^{|V|}$. By Observation 3, has the equality $|\mathcal{E}_V(C)|=2^{|V|-|\mathit{Var}(C)|}$. Hence, one obtains $\sum_{C \in \Gamma} | \mathcal{E}_V(C)|= \sum_{C \in \Gamma} | 2^{|V|-|\mathit{Var}(C)|}| <2^{|V|}$. And since this sum only requires the length of the original clause and the exponent can also be computed in linear time one only has to compute the given some to decide satisfiability of $\Gamma$.
%
%\item Bonus: determine whether {\bf Read-$k$ SAT}, where $k>1$ is fixed, is
%tractable, for each $k$.
%
%For $k=2$ see the actual exercise. Hence, consider an arbitrary $k>2$. Any of those {\bf Read-$k$ SAT} is not tractable, which can be shown through the reductions $\textbf{CNF} \leq_m^P\textbf{Read-}3 \,\textbf{SAT}$ and $\textbf{Read-}3\,\textbf{SAT} \leq_m^P\textbf{Read-}k \,\textbf{SAT}$. Starting with the prior. Let $\varphi$ be some CNF-formula, where $\mathit{Var}(\varphi):=\{x_1,\dots , x_n\}$ and where $\mathit{Cl}(\varphi):=\{C_1, \dots C_m\}$ such that no variable occurs twice in the same clause. This assumption is sound, because 
%\begin{itemize}
%\item  if a variable occurs multiple times in the same clause with the same polarity, i.e. either only positively or only negatively, all but one of those occurrences can be removed;
%\item if a variable occurs both positively and negatively in a clause this clause can be removed
%\end{itemize}.   
%and since checking this can clearly be done in polynomial time.
%Moreover, let $x_{ij}$ for $i \in \{1,\dots , n\}$ and $j \in \{1,\dots, m\}$ be fresh variables. Now consider $\tau$
%\begin{equation*}
%\begin{split}
%\tau(\varphi) := & \psi = \psi_c \land \psi_e \\
%= &\bigwedge_{j \in \{1,\dots , m\}} C[x_1 / x_{1j}, \dots , x_n / x_{nj}]  \land \\
%& \bigwedge_{i \in \{1,\dots , n\}}  \big(   (\neg x_i \lor x_{i1})  \land  \bigwedge_{j \in \{1,\dots , m-1\}}  (x_{ij}  \lor \neg x_{i(j+1)})  \land (\neg x_{im} \lor x_{i})\big)
%\end{split}
%\end{equation*}
%
%Firstly, the $ \psi_e$ forces for each variable $x_i$ that the following circle of implications is uphold $x_i \Rightarrow x_{i1} \Rightarrow  x_{i2} \Rightarrow \dots  x_{im} \Rightarrow x_i$, i.e. it expresses equality among all $x_{ij}$ for all $j\in \{1, \dots ,m\}$ and with $x_i$.
%Secondly, each $x_{ij}$ occurs at most once in $\mathit{Var}(\psi)$, since $x_i$ occurs at most once in the clause $C_j$. Moreover, $x_{ij}$ occurs clearly exactly twice in $\psi_e$. Therefore, each variable occurs at most three times in $\psi$. 
%Thirdly, $\psi_c$ is the same size as $\varphi$ and $\psi_e$ is linear with respect to the number of clauses times the number of variables in $\varphi$. Hence, the transformation can be done in polynomial time. \\
%
%Lastly, it has to be demonstrated that $\varphi \; \mathit{sat.} \iff \psi \; \mathit{sat.} $.
%
%
%$"\Rightarrow"$. If $\varphi$ is satisfiable, then there exists an assignment $\sigma$ under which $\varphi$ is satisfiable. Let $\sigma_{\tau}$ be an extension of $\sigma$ such that $\sigma_{\tau}:= \sigma \cup \{ x_{ij} \mapsto \sigma(x_i) \mid \forall i \in \{1,\dots ,n\} \forall j \in \{ 1, \dots, m\}\}$. Since, meaning that under this interpretation $x_i$ is replaced in $\psi_c$ with an object of the same truth value. Hence, $\psi_c$ is satisfied under $\sigma_{\tau}$. Moreover, with $\psi_e$ encoding a series of equivalences between $x_{ij}$ and $x_i$ for some fixed $i$, this assignment, ensuring equal evaluation of exactly those variables, must therefore satisfy $\psi_e$ as well.
%
%
%$"\Leftarrow"$. if $ \psi$ is satisfiable, then there exists an assignment $\sigma$ under which $\varphi$ is satisfiable. Under this assignment every variable in the set $\{x_i\}  \cup \{ x_{ij} \mapsto \sigma(x_i) \mid \forall j \in \{ 1, \dots, m\}\}$ for any fixed $i$ must be evaluated the same. Otherwise, $\psi_e$ would not have been satisfied. Hence, $\psi_c$ is satisfied by an assignment where every instance of $x_i$ has the same truth value. Therefore, by restricting $\sigma$ to the variables in $\varphi$ results in an satisfying assignment for $\varphi$.
% 
% 
%
%The reduction $\textbf{Read-}3\,\textbf{SAT} \leq_m^P\textbf{Read-}k \,\textbf{SAT}$ is trivial. Meaning, any instance of $\textbf{Read-}3\,\textbf{SAT} $ of $\textbf{Read-}k \,\textbf{SAT}$. Hence, if $\textbf{Read-}k \,\textbf{SAT}$ would be tractable, then $\textbf{Read-}3\,\textbf{SAT}$ must be as well, which by transitivity would mean that $\textbf{SAT}$ would can be solved in deterministic polynomial time.
%
%
%\end{itemize}
%
%
%
%\newpage
%
%
%\item (10) Suppose that \NP = \coNP holds. Try to argue, by considering
%nondeterministic Turing machines with oracles, that then $\NP^{\NP} = \NP$ would hold.
%
%\item (10) Show that the following restriction of {\bf
%QBF$_{2,\forall}$}, called {\bf NOT ALL EQUAL (NAE-) QBF$_{2,\forall}$}, is $\PiP{2}$-complete: an instance $\forall
%\vec{x}\exists\vec{y}E$ of {\bf QBF$_{2,\forall}$}
%where $\vec{x}=x_1,\ldots, x_n$, $\vec{y}= y_1,\ldots,y_m$,  $E=C_1,\ldots,C_k$ is in conjunctive normal form (a conjunction of
%clauses $C_i$), is a Yes-instance, if for each value assignment $\sigma$ to $\vec{x}$,
%there exists some value assignment  $\mu$ to $\vec{y}$ such that in
%every clause $C_i$, some literals $\ell,\ell'\in C_i$ have opposite truth
%value under the combined assignment $\sigma \cup \mu$. (Note that every
%Yes-instance of {\bf (NAE-) QBF$_{2,\forall}$} is a Yes-instance of {\bf
% QBF$_{2,\forall}$}, but not vice versa.)
%
% 
%\item (10)  Consider the following complexity classes:
%
%\begin{itemize}
% \item[] $\LOG^{\Pol}$,\quad $\NLOG^{\Pol}$, \quad $\Pol^{\NLOG}$, \quad $\LOG^{\NLOG}$
%\end{itemize}
%
%Clarify the relationships of these classes wrt.\ inclusion
%$\subseteq$  and the classes $\LOG$, $\NLOG$, $\Pol$, and $\NP$ (note: mind space
%restrictions for oracles).
%
%
%\newpage
%
%
%\item (10) \label{WSAT} Consider the following variant of {\bf SAT}, called {\bf Weighted
%     SAT}: the instance consists of a (propositional) CNF $F =
%        \bigwedge_{i=1}^m c_i$, integer weights $w(c_i)>0$ for all
%        clauses $i=1,\ldots,m$.
%
%     A {\em maximum weight assignment}\/ is a truth assignment
%    $\sigma$ to the variables in $F$ such that the total weight of
%                clauses satisfied by $\sigma$, i.e.,
%    $ w(\sigma) = \sum_{i=1}^k w(c_i)*\sigma(c_i)$,  is maximum. 
%              
% \begin{enumerate}
%
%       \item Show that, given an integer $k \geq 0$, deciding whether
%            $w(\sigma)\geq k$ for some maximum weight assignment
%                $\sigma$ is \NP-complete. 
%
%                                
%       \item Show that, deciding whether for any maximum weight assignment
%                $\sigma$, the number $w(\sigma)$ is even is $\DeltaP{2}$-complete. 
%                                
% \end{enumerate}
%
%Bonus: Given an integer $k \geq 0$, what is the complexity of deciding whether
%            $w(\sigma)\leq k$ for every maximum weight assignment
%            $\sigma$ ?
%
%            
%           
%             \begin{enumerate}
%
%       \item Show that, given an integer $k \geq 0$, deciding whether
%            $w(\sigma)\geq k$ for some maximum weight assignment
%                $\sigma$ is \NP-complete. \\
%       
%Let the problem described above be called  $k\text{-}\textbf{WSAT}$
%First hardness will be shown by giving a polynomial time reduction from {\bf CNF} to $k\text{-}\textbf{WSAT}$. Hence, by giving such a reduction it follows that $k\text{-}\textbf{WSAT}$ has to be at least \NP-hard. Otherwise, \textbf{CNF} would not be \NP-complete.
%To establish $\textbf{CNF} \leq_m^P k\text{-}\textbf{WSAT}$, it has to be shown that there exists function $f$ that is computable in polynomial time wrt. to its input size such that for all inputs $x$, $\chi_{\textbf{CNF}} (x)= \chi_{k\text{-}\textbf{WSAT}}(f(x))$ holds. \\
%
%Firstly, let $\mathcal{C}(\varphi)$ be the set of all clauses of an CNF-formula $\varphi$. Now, consider an input formula $\varphi$ for \textbf{CNF} and the following transformation:
%\begin{equation*}
%f(\varphi):= (\varphi, w, k)
%\end{equation*}
%where 
%\begin{itemize}
%\item $w(c)=1$ for all clauses $c \in \mathcal{C}(\varphi)$;
%\item $k=| \mathcal{C}(\varphi) |$.
%\end{itemize}
%
%Assume that $\varphi$ is satisfiable, i.e. $\chi_{\textbf{CNF}} (\varphi)=1$. Hence, all of its clauses are satisfied by the truth assignment $\sigma$. Hence, considering the weight function $w$ obtained through $f$ one obtains $w(\sigma) = \sum_{c \in \mathcal{C}(\varphi)} w(c)*\sigma(c)= \sum_{c \in \mathcal{C}(\varphi)}1*\sigma(c)  = |\mathcal{C}(\varphi)|$. That is, all clauses are satisfied and all clauses have the weight $1$. Clearly, $\sigma$ is a maximum weight assignment, in fact by construction any other truth assignment satisfying $\varphi$ has the same weight as $\sigma$. Lastly, since $k= |\mathcal{C}(\varphi)|$  it follows that $\chi_{k\text{-}\textbf{WSAT}}(f(\varphi))=1$.
%
%Assume that $\varphi$ is not satisfiable, i.e. $\chi_{\textbf{CNF}} (\varphi)=0$. Meaning that there does not exist a truth assignment which satisfies all clauses in $\varphi$. That is, for all truth assignments $\sigma$ it follows that $w(\sigma) = \sum_{c \in \mathcal{C}(\varphi)} w(c)*\sigma(c) =\sum_{c \in \mathcal{C}(\varphi)}1*\sigma(c)   < |\mathcal{C}(\varphi)|$. Hence,  no maximum weight assignment of weight greater or equal to $k$ exists, thus one obtains $\chi_{k\text{-}\textbf{WSAT}}(f(\varphi))=0$.
%
%Lastly, it has to be established that $f$ can be computed in polynomial time. Since, $w$ is constant it can be constructed on constant time. Hence, the only computationally demanding in the transformation is to count the number of clauses in $\varphi$. However, this can clearly be accomplished on linear time wrt. to the number of clauses and since those are bound by the size of the formula, one can conclude that $f$ runs in polynomial time. Hence, completing the reduction. \\
%
%
%Having established  \NP-hardness, it remains to show \NP-membership. To do so a simple guess and check algorithm is sketched. 
%                                
%\texttt{
%\begin{tabbing}
%guess($\sigma$); /* guess a truth assignment for $\varphi$*/  \\
%if $\sigma$ \=satisfies $\varphi$ and $w(\sigma) \geq k$ then: \\
%     \> succeed; \\
%else: \\
%     \>  fail; \\
%\end{tabbing}}
%
%This algorithm returns the required results due to the fact that as soon as one has found an assignment with weight greater or equal $k$, it is clear that any maximal assignment $\sigma_{max}$ has to have a weight greater or equal to $k$ as well. Moreover, this algorithm employs the guess and check method introduced in the lecture. That is, first one guesses an assignment and then check whether this assignment satisfies the formula $\varphi$. As established in the lecture, this checking can be done in polynomial time. Similarly, summing up the weights can also be done in polynomial time. Hence, one can conclude that this algorithm establishes \NP-membership. Together with the previous results it \NP-completeness follows in kind.
%
%%\texttt{
%%\begin{tabbing}
%%(defrule \= R1 ``poor person'' \\
%%\> ?P1 \= $\leftarrow$  \\
%%\>\>(Per\=son\\
%%\>\>\> (employedEarningsPerYear $<$ 15000)\\
%%\>\>\> (selfEmployedEarningsPerYear $<$ 5000)\\
%%\>\>) \\
%%) $\Longrightarrow$ \>assert(?P1 (poor true))\\    
%%\end{tabbing}
%
%
%
%       \item Show that, deciding whether for any maximum weight assignment
%                $\sigma$, the number $w(\sigma)$ is even is $\DeltaP{2}$-complete. 
%
%Let the problem described above be called  $\textbf{e-WSAT}$            
%Similarly, as before $\DeltaP{2}$-hardness will be established first. To that end a reduction from $\textbf{MSA}$ to  $\textbf{e-WSAT}$  , i.e.  $\textbf{MSA} \leq_m^P \textbf{e-WSAT}$  is presented. Hence, consider the following transformation $\tau$ where
%\begin{equation*}
%\tau(\pi(\chi), (x_1, \dots , x_n)) := (\psi, w)
%\end{equation*}
%where $\varphi:=\pi(\chi)$ is a formula in CNF, i.e. $\pi$ is some standard CNF transformation (e.g. Tseytin transformation), and $(x_1, \dots , x_n)$ is a vector indicating an ordering over the set of variables in $\chi$, i.e. $\mathit{Var}(\chi)$. Moreover, for $n:=|\mathit{Var}(\chi)|$
%\begin{equation*}
%\begin{split}
%\psi := &\psi_c \land \psi_x \land \psi_p = \big( \bigwedge_{C \in \mathit{Cl}(\varphi)} (\neg x \lor C) \big) \land \big( \bigwedge_{i \in \{1,\dots,n\}} x_i \big) \land p\\
%w := & \{ (p) \mapsto  2^{n+1}\} \cup  \{(\neg x \lor C)  \mapsto 2^{n+3} \mid \forall C \in \mathit{Cl}(\varphi)\}\\ 
% & \cup \{  (x_i) \mapsto 2^{(n-i)} \mid \forall i \in \{ 1, \dots, n\}\} 
%\end{split}
%\end{equation*}
%Since $\pi$ is known to be polynomial and number of additional clauses is linear with respect to the number of variables in $\chi$ the whole transformation can be done in polynomial time.
%
%
%\emph{Observation 1: $2^n > \sum_{i=0}^{n-1} 2^i$.} \\
%
%\emph{Observation 2: If there exists a satisfying assignment of the formula $\varphi$,  then $p$ is satisfied under every weight maximal assignment.}
%
%Consider an weight maximal assignment $\sigma$ where $\sigma(p)=0$. This assignment clearly satisfies every clause in $\psi_c$ without relying on the variables $x_1, \dots , x_n$. Hence, in order for this assignment to be maximal all clauses in $\psi_x$ are satisfied. That is, the only clause not satisfied is $(p)$. However, $w(p) > \sum_{C \in \mathit{Cl}(\psi_x)} w(x)$. Meaning that as long as the same clauses in $\psi_c$ are satisfied, any assignment $\sigma'$ such that $\sigma'(p)=1$ has a greater weight that $\sigma$. Now, given the assumption that $\varphi$ is satisfiable, all clauses in $\psi_c$ can be satisfied, without fixing the assignment of $p$. Hence, if $\varphi$ is satisfiable, there exists at least one of such assignment, which then must be chosen by maximality. \\
%
%\emph{
%Observation 3: For two satisfying assignment of $\varphi$, $\sigma_1$ and $\sigma_2$ , $\sigma_1 \prec_{lex} \sigma_2$ with respect to the vector $(x_i)_{i \in \{1, \dots n\}}$, if and only if $w(\sigma_1) < w(\sigma_2) $.  }
%
%
%Firstly, since both assignments satisfy $\varphi$  is always satisfied, the order induced by the weight does only depend on which "variable" clause in $\psi_x$ is satisfied. Hence, it suffices to focus solely on that part.
%Assume  $\sigma_1 \prec_{lex} \sigma_2$ with respect to the vector $(x_i)_{i \in \{1, \dots n\}}$ then there exists one $k$ such that for all $1 \leq i < k$ it holds that $\sigma_1(x_i)=\sigma_2(x_i)$ and that $\sigma_1(x_k)<\sigma_2(x_k)$, with the remaining variables being arbitrary. Now since $2^{k-1} > \sum_{i=0}^{k-2} 2^i$ the assignment of variables $x_i$ for $i>k$ is irrelevant, i.e. even if all variable clauses greater $k$ are satisfied they can not outweigh $w(x_k)$. Therefore the inequality $w(\sigma_2)>w(\sigma_1)$ must hold. 
%Assuming that  $w(\sigma_1) < w(\sigma_2)$. For the subformula $\psi_x$, those have the form $\omega_1 := \sum_{i \in \{1, \dots, n\}} \sigma_1(x_i) \cdot 2^{n-i}$ and $\omega_2 := \sum_{i \in \{1, \dots, n\}} \sigma_2(x_i) \cdot 2^{n-i}$. Since $\omega < \omega_2$, $\sigma_1$ and $\sigma_2$ must differ at least on one position. Let $k$ be the first of those differences. Similar as before, since satisfying the position $k$ outweighs every possible assignment of the variable clauses after $(x_k)$, i.e. $(x_i)$ for $k<i$, it must be the case that $\sigma_2(x_k)=1$ and   $\sigma_1(x_k)=0$, thus $\sigma_1 \prec_{lex} \sigma_2$.  \\
%
%
%\emph{Observation 4: If $p$ is satisfied under a weight maximal assignment $\sigma$, then $\varphi$ is satisfied under $\sigma$.}
%
%Since $\sigma(p)=1$, it follows that $(p)$ is satisfied. Additionally, since $w(C)>w(p)$ for any $C \in \mathit{Cl}(\psi_c)$, if any of the clauses in $\psi_c$ would not be satisfied, flipping the assignment of $p$ would increase the total weight of the assignment. However, with $\sigma$ being weight maximal, one can thus conclude that all clauses in $\psi_c$ are satisfied. Hence, $\sigma$ is also a satisfying assignment of $\varphi$. \\ 
%
%$"\Rightarrow"$: Assume that the instance $(\chi, (x_1, \dots , x_n))$ is a satisfying instance of the problem $\textbf{MSA}$. Hence, $\chi$ is satisfiable and the maximal lexicographical assignment $\sigma$ evaluates $x_n$ to $1$. Since, $\pi$ preserves satisfiability, in such a way that restricting an assignment for $\varphi:=\pi(\chi)$ to the variables only occurring in $\chi$ provides a model for $\chi$.  Meaning that every clause in $\mathit{Cl}(\varphi)$ is satisfiable. Hence, $p$ will be satisfied under any maximal weight assignment. Moreover, by assumption $x_n$ will be satisfied, thus the total weight of the assignment will be even. Moreover, since $x_n$ is satisfied under the lexicographical maximal assignment, by Observation 3,  it must be satisfied under the weight maximal assignment as well. Thus it is a positive instance of $\textbf{e-WSAT}$.  
%
%
%$"\Leftarrow"$: Assume that the instance $\psi$,  is a satisfying instance of the problem $\textbf{e-WSAT}$.  Meaning for some weight maximal assignment $\sigma$, $w(\sigma)$ is even. Recall $\varphi = \bigwedge_{(\neg x \lor C) \in \mathit{Cl}(\psi_c)} C$. There are two cases. 
%\begin{itemize}
%\item Case 1: $\sigma(p)=0$ and $\sigma(x_n)=0$\\
%By Observation 2 $\varphi$, and therefore $\chi$, can not be satisfied. Since, $\sigma(p)=0$ all clauses in $\psi_c$ are satisfied. Hence, the variables $x_1, \dots , x_n$ can be chosen freely without interfering with the truth value of the clauses clauses in $\psi_c$. Thus, there exists an assignment $\sigma'$ that is the same $\sigma$, except $\sigma'(x_n)=1$. Clearly, $w(\sigma')>w(\sigma)$ and $w(\sigma')$ odd. Implying the impossibility of this case.
%
%
%\item Case 2: $\sigma(p)=1$ and $\sigma(x_n)=1$\\
%Since, $\sigma$ is weight maximal, it follows form Observation 4, that $\varphi$ is satisfied under $\sigma$ such that $\sigma(x_n)=1$. Moreover, from this and from Observation 3, it follows that the weight maximal assignment is also the lexicographical maximal assignment. Thus by restricting $\sigma$ to the variables in $\chi$ one obtains a lexicographical maximal assignment in which $x_n$ evaluates to $1$. Hence, the original problem is a positive instance of $\textbf{MSA}$. 
%\end{itemize} 
%
%\bigskip
%In a last step membership has to be shown. In order to establish membership, it suffices to give an appropriate algorithm. The idea of which is fairly simple:
%\begin{itemize}
%\item Use an algorithm $\mathcal{A}_{WSAT}(\varphi, k)$ that solves for $k\text{-}\textbf{WSAT}$ as an oracle. 
%\item Check if there exists a satisfying assignment, if there does not return false. 
%\item Otherwise, run binary search to find the greatest $k$, such that $\forall n > k$ the input ($\varphi$, $n$) is no longer an accepted instance of $k\text{-}\textbf{WSAT}$.
%\item if $k$ is even return true; else return false
%\end{itemize}
%If there exists a solution, this program will return a smallest satisfying assignment. Moreover, since the complexity of binary search is $\mathcal{O}(log n)$, the oracle will be called upon at most a logarithmic amount of times, wrt. to the total weight (which is smaller than the number of clauses times the greatest weight of an clause, the magnitude of both is smaller that the total size of the input).
%
% \texttt{
%\begin{tabbing}
%e-\=SAT($\varphi, w$): \\
%\> $u:= \sum_{c \in \mathit{Cl}(\varphi)} w(c)$ \\
%\> $l:= 0$ \\
%\> while \=  $u \neq l$: \\
%\>\> $n:= \lceil \frac{u+l}{2} \rceil$ \\
%\>\> if \= $\mathcal{A}_{WSAT}(\varphi,n)=$ true: \\
%\>\>\> $l:= n$ \\
%\>\> else: \\ 
%\>\>\> $u:= n-1$  \\
%\> if $u$ is even: \\
%\>\> return true \\
%\> else: \\
%\>\> return false \\
%\end{tabbing}}
%
%%
%%
%%
%%To that end assume that there exists an algorithm $\mathcal{A}$ with a runtime strictly below $\DeltaP{2}$. Using this algorithm it will be shown that $\textbf{CNF\text{-}}MSA$., i.e $\textbf{MSA}$ for formulas in CNF, is not $\Delta^P_2$-hard. Requiring in a last step to give a reduction from $\textbf{MSA}$ to $\textbf{CNF\text{-}}MSA$.
%%
%%The constructed algorithm will 
%%\begin{enumerate}[1.]
%%\item Take the formula $\varphi$ and an ordering of $Var(\varphi)$, represented as a vector $(x_i)_{i \in \{1, \dots, n\}}$.
%%\item Use the Tseytin transformation $\tau$ to obtain a CNF formula $\tau(\varphi)$ (preserves satisfiability)
%%\item Establish satisfiability by using $\mathcal{A}$ in linear time wrt. the number of clauses.
%%\begin{itemize}
%%\item This will be done by iteratively adding clauses;
%%\item running $\mathcal{A}(\tau(\varphi), \overline{1})$, where $\overline{1}$ is simply the constant function $1$;
%%\item Checking if the output is different from the previous iteration.
%%\end{itemize}
%%\item Run $\mathcal{A}(\tau(\varphi) \land x_1 \land \dots \land x_n, w')$ where $w'$ is a weight function constructed such that 
%%\begin{itemize}
%%\item satisfying the clauses of $\tau(\varphi)$ has the highest priority;
%%\item the lexicographical order is preserved, e.g. an assignment satisfying $x_1$ must always be greater that any assignment satisfying $\neg x_1$, and so on.
%%\end{itemize}
%%\end{enumerate}
%%
%%To be more concrete,
%%
%% \texttt{
%%\begin{tabbing}
%%CNF-\=MSA-Solver($\varphi_{inp}$, $(x_i)_{i \in \{ 1, \dots, n \} }$): \\
%%\> $\varphi := \tau(\varphi_{inp})$ \\
%%\> $\psi := \{\}$  // Empty Formula \\
%%\> $e :=$ True \\
%%\> for \=$C \in \mathcal{C}(\varphi)$:   // Set of clauses\\
%%\>\> $\psi := \psi \land C$  \\
%%\>\> If \=$\mathcal{A}(\psi, \overline{1})\neq e$ and $C\neq \Box$:  // Empty Clause\\
%%\>\>\> $e := \neg e$ \\
%%\>\> else: \\
%%\>\>\> return false \\
%%\> $\psi' := \varphi \land x_1 \land \dots \land x_n$ \\
%%\> $w' := \{\}$  // Empty Function \\
%%\> for $i \in \{ 1, \dots, n \}$: \\
%%\>\> $w' := w' \cup \{x_i \mapsto 2^{(n-i)}\}$\\
%%\> for \=$C \in \mathcal{C}(\varphi)$:   // Set of clauses\\
%%\>\> $w' := w' \cup \{C \mapsto 2^{n}\}$ \\
%%\> return $\neg \mathcal{A}(\psi', w')$
%%\end{tabbing}}
%%
%%Starting with a justification for the first \texttt{for}-loop. On the one hand,  consider a satisfiable CNF-formula $\varphi$. Hence, every $C \in \mathcal{C}(\varphi)$ is satisfiable. Therefore, given the constant function $\overline{1}$, the maximal weighted assignment of $\varphi_U :=\bigwedge_{C \in U \subseteq \mathcal{C}} C$ is equal to $|U|$. Now starting from the empty subset $0$ clauses are satisfied, thus $\mathcal{A}(\varphi_{\emptyset}, \overline{1})$ returns true. Since $\varphi_U$ for any $U \subseteq \mathcal{C}$ must be satisfiable, adding additional clauses must increase the maximal weight assignment. Hence, if  $\mathcal{A}(\varphi_{U}, \overline{1})$ is true, it must be the case that $\mathcal{A}(\varphi_{U \land C}, \overline{1})$ must therefore be false. And vice verse. Therefore, one never falls into the case of $\mathcal{A}(\psi, \overline{1})= e$. On the other hand, if  $\varphi$ is not satisfiable, i.e. there exists at least one clause that is not satisfied. Then there must be a point where the maximal weighted assignment does not increase. Moreover, since only one clause is added at a time, this is detected by the fact that $\mathcal{A}$ does return the same value as in the previous iteration (Note: Adding a clause can not decrease the maximal weighted assignment.).
%%Which the causes the algorithm to terminate and declare $(\varphi, (x_i)_{i \in \{ 1, \dots, n \} })$ as a negative instance.  Therefore, from now on $\varphi$ is always to be considered satisfiable. \\
%%
%%
%%
%%Observation 2: All original clauses in $\psi_c$ are satisfied under every maximal weighted assignment. 
%%The total weight of 
%%If $\varphi$ is not satisfiable, 
%%If $\varphi$ is satisfiable. Assume that there exists a maximal weighted assignment $\sigma$ such that there exists a clause $C \in \mathit{Cl}(\psi_c)$ that is not satisfied under $\sigma$. Hence, there must exists an assignment of the variable clauses $(x_1) , \dots , (x_n)$ that has a greater weight than $C$. Clearly, the sum of weights of the variable clauses under this assignment must be smaller or equal to $\sum_{i=0}^{n-1} 2^i$. However, given the observation above satisfying the clause rather than the multiple variable clauses would result in a greater weighted assignment. Hence, the original one can not be maximal. \\
%%
%%Observation 3: For two satisfying assignment $\sigma_1$ and $\sigma_2$, $\sigma_1 \prec_{lex} \sigma_2$ if and only if $w(\sigma_1) < w(\sigma_2) $.  
%%
%%Assume  $\sigma_1 \prec_{lex} \sigma_2$ then there exists one $k$ such that for all $1 \leq i < k$ it holds that $\sigma_1(x_i)=\sigma_2(x_i)$ and that $\sigma_1(x_k)<\sigma_2(x_k)$, with the remaining variables being arbitrary. Again by the same argument as above we have $2^{k-1} > \sum_{i=0}^{k-2} 2^i$ and thus regardless of the assignments of variables $x_i$ for $i>k$ the inequality $w(\sigma_2)>w(\sigma_1)$ must hold. Assuming that  $w(\sigma_1) < w(\sigma_2)$ !!!!!!! \\
%%
%%Given, those two observation it follows that any maximal weighted assignment is a satisfying assignment of $\varphi$ and that is also lexicographically maximal. Now, with $w(x_n)=1$ it is the only clause with an odd weight. Hence, if $\mathcal{A}$ returns true, it must follow that $x_n$ is not satisfied, similarly, if $\mathcal{A}$ returns false, one can conclude $x_n$ is satisfied. \\
%%
%%Lastly, there is only a polynomial (wrt. number of clauses) amount of calls to $\mathcal{A}$ in \texttt{CNF-MSA-Solver}. Similarly, all other actions can clearly be done in polynomial time as well. Thus, if $\mathcal{A}$ would exists, $\textbf{CNF\text{-}}MSA$ would not be $\Delta_2^P$-hard. \\
%
%\item Bonus: Given an integer $k \geq 0$, what is the complexity of deciding whether
%            $w(\sigma)\leq k$ for every maximum weight assignment
%            $\sigma$ ?
%            
%As established above given an integer $k \geq 0$, deciding whether
% $w(\sigma)\geq k$ for some maximum weight assignment
%$\sigma$ is \NP-complete. Written more concise 
%\begin{equation*}
%\exists \sigma \; (\sigma \; \textit{maximum weight assignment } \land  w(\sigma)\geq k)
%\end{equation*}
%                
%Hence, the negation of this problem is, given an integer $k \geq 0$  
%\begin{equation*}
%\forall \sigma \; (\neg \sigma \; \textit{maximum weight assignment } \lor  \neg w(\sigma)\geq k)
%\end{equation*}
%which is the same as
%\begin{equation*}
%\forall \sigma \; ( \sigma \; \textit{maximum weight assignment } \implies  w(\sigma)< k)
%\end{equation*}
%Therefore, the problem: Given an integer $k \geq 0$, what is the complexity of deciding whether $w(\sigma)\leq k$ for every maximum weight assignment $\sigma$. Is merely the negation of the problem $(k+1)\text{-}\textbf{WSAT}$. That is,
%\begin{equation*}
%\exists \sigma \; (\sigma \; \textit{maximum weight assignment } \land  w(\sigma)\geq k+1)
%\end{equation*}
%is equal to 
%\begin{equation*}
%\forall \sigma \; ( \sigma \; \textit{maximum weight assignment } \implies  w(\sigma)< k+1)
%\end{equation*}
%which is equal to 
%\begin{equation*}
%\forall \sigma \; ( \sigma \; \textit{maximum weight assignment } \implies  w(\sigma)\leq k)
%\end{equation*}
%Now, given the fact that $(k+1)\text{-}\textbf{WSAT}$ is \NP-complete, its complement is \coNP-complete.
% \end{enumerate}
%            
%            
%\newpage            
%            
%%############################################## 
%            
%            \item (10) The class  ${\bf F}\Pol^\NP[log, wit]$
%(cf.\ Unit 1) contains the search problems that can be solved in polynomial time with a
%witness oracle, which loosely speaking returns some solution to a
%problem in \NP (e.g., for {\bf SAT}, a satisfying assignment). 
%
%A search problem $\Pi$ can be solved in $\FPNPlogwit$, if for
%every instance $I$ of $\Pi$  some solution of $I$ can be computed in
%polynomial time with a witness oracle for $\NP$, which can be consulted
%at most $O(\log n)$ times, where $n=|I|$ is the length of the input.
%
%\begin{enumerate}[(a)]
% \item show that computing some smallest (w.r.t.\ cardinality) model  of a
%        Boolean formula is in $\FPNPlogwit$;
% \item show that computing some minimal (w.r.t.\ $\subseteq$) model of a
%        Boolean formula is in $\FPNPlogwit$;
%        
% \item Technically, $\FPNPlogwit$ requires that each input has some
% output, i.e., it consists of \emph{total (multi-valued) functions}\/ (thus, for computing a
% maximum model of a SAT instance $E$, a special value like ``unsat''
% is output in order to flag unsatisfiability); and each run produes output.
%
%Show that $\FPNPlogwit \subseteq \FPNP$, where $\FPNP$ are the 
%search problems $\Pi$ such that for
%every instance $I$ of $\Pi$ some solution of $I$ can be computed in
%polynomial time with an ``ordinary'' oracle for $\NP$.
%
%Bonus: consider whether this inclusion would hold if problem instances
%may have no solutions, and in this case computations do not generate output.
%\end{enumerate}
%
%
%
%WARNING: This whole exercise relies on the fact that $\mathbf{FSAT}$ is an $\mathbf{FNP}$-complete problem. 
%
%\begin{enumerate}[(a)]
% \item show that computing some smallest (w.r.t.\ cardinality) model  of a
%        Boolean formula is in $\FPNPlogwit$; \\
%        
%        
%        
%\emph{Observation 1: The problem $\textbf{FSAT}_{\leq k}$ taking an $k\in \mathbb{N}$ and an propositional formula $\varphi$ as input,  and returning a model of size smaller or equal to $k$ is \textbf{FNP}-complete. }
%
%\emph{Membership:} Consider
%
% \texttt{
%\begin{tabbing}
%$\text{FSAT}_{\leq k}$\=($\varphi$, $k$): \\
%\> $\mathcal{M}$ := guess($\varphi$)      // guess an assignment for $\varphi$ \\
%\> if \= $|\mathcal{M}|\leq k$ and $\mathcal{M} \models \varphi$ : \\
%\>\> return $\mathcal{M}$ \\
%\> else : \\
%\>\> return false \\
%\end{tabbing}}
%This algorithm is a guess and check algorithm running in polynomial time and returning, if possible, a result for the actual problem. Thereby establishing membership 
%
%
%
%\emph{Hardness:} $\mathbf{FSAT}$ returns a model of any size, if $\varphi$ is satisfiable. Moreover, those model are at most of size $|\mathit{Var}(\varphi)|$. Therefore, it is clear to see that$\mathbf{FSAT}$ is merely an special case of  $\mathbf{FSAT}_{\leq k}$, namely $\mathbf{FSAT}_{|\mathit{Var}(\varphi)|}$. Given the fact that $\mathbf{FSAT}$ is $\mathbf{FNP}$-complete, one obtains $\mathbf{FNP}$-hardness.   \\
%
%
%
%
%In order to establish membership, it suffices to give an appropriate algorithm. The idea of which is fairly simple:
%\begin{itemize}
%\item Use  $\mathbf{FSAT}_{\leq k}$ as an oracle. 
%\item Check if there exists a satisfying assignment, if there does not return false. 
%\item Otherwise, run binary search to find the smallest $k$, such that $\forall i < k$ the input ($\varphi$, $i$) is no longer an accepted instance of $\mathbf{FSAT}_{\leq i}$. 
%\item return the last satisfying model.
%\end{itemize}
%If there exists a solution, this program will return a smallest satisfying assignment. Moreover, since the complexity of binary search is $\mathcal{O}(log n)$, the oracle will be called upon at most a logarithmic amount of times, wrt. the number of variables in $\varphi$.
%Moreover, only the last call of $\mathbf{FSAT}_{\leq k}$ is important, all other calls could can also be done with a normal decision oracle.
%To be more specific.
%
% \texttt{
%\begin{tabbing}
%Min-\=Card-SAT($\varphi$): \\
%\> $u:= | \mathit{Var}(\varphi)|$ \\
%\> $l:= 0$ \\
%\> if \= $\text{FSAT}_{\leq k}(\varphi,u) =$ false: \\
%\>\> return false \\
%\> while $u \neq l$: \\
%\>\> $n:= \lfloor \frac{u+l}{2} \rfloor$ \\
%\>\> $\mathcal{M}:= \text{FSAT}_{\leq k}(\varphi,n) $ \\
%\>\> if \= $\mathcal{M} =$ false: \\
%\>\>\> $l:= n+1$ \\
%\>\> else: \\ 
%\>\>\> $u:= n$  \\
%\> return $\mathcal{M}$  \\
%\end{tabbing}}
%
%
% \item show that computing some minimal (w.r.t.\ $\subseteq$) model of a
%        Boolean formula is in $\FPNPlogwit$;
%        
%        In order to establish membership, it suffices to give an appropriate algorithm. However, in this particular case membership directly follows form the following observation. \\
%        
%        
%        
%\emph{        Observation 2: Any minimal model with respect to cardinality is a subset minimal model.
%        }
%        
%        
%        This observation is trivial, as otherwise, there would be another model with less elements than a model with smallest number of elements. Which is clearly a contradiction. \\
%        
%        Since, the problem only requires the computation of \emph{some} subset minimal model, it is clear that this can be done by computing a smallest model with respect to cardinality. Therefore, establishing $\FPNPlogwit$ membership, through the runtime 	of \texttt{Min-Card-SAT($\varphi$)}.
%        
% \item Show that $\FPNPlogwit \subseteq \FPNP$, where $\FPNP$ are the 
%search problems $\Pi$ such that for
%every instance $I$ of $\Pi$ some solution of $I$ can be computed in
%polynomial time with an ``ordinary'' oracle for $\NP$.
%
%
%%\emph{Observation 1: Any \NP-complete problem is self-reducible. That is, given an oracle for an \NP-complete problem \mathit{L}, there exists a polynomial algorithm that can be used for solving its corresponding the functional problem $FL$.}
%
%The core of this proof is the to use the concept of self-reducibility from decision to search problems. 
%The main idea required for showing that result is to use the concept of self-reducibility to show that it is possible to replace a single call to the \NP-complete witness oracle by a polynomial number of calls to a \NP-complete decision oracle. However, to show self-reducibility of \NP-complete decision and search problems, two proof variants will be presented.  This is, due to the fact that the first one uses many notions not formally introduced in the course. For example, the fact that $\mathbf{FSAT}$ is \textbf{FNP}-complete, as well as the notion of reduction with respect to search problems. 
%
%
%\emph{
%Observation 3: \textbf{SAT} is self-reducible}
%
%That is, 
%\begin{itemize}
%\item Given an oracle of \textbf{SAT}, solve \textbf{FSAT} in polynomial time.
%\item Given an oracle of \textbf{FSAT}, solve \textbf{SAT} in polynomial time.
%\end{itemize}
%The latter is trivial, i.e. ask \textbf{FSAT} once for a model, if a model is returned the formula in question is clearly satisfiable.
%As for the prior, consider the following algorithm.
%
% \texttt{
%\begin{tabbing}
%FS\=AT($\varphi$): \\
%\> If \= SAT($\varphi$) = FALSE: \\
%\>\> return FALSE \\
%\> $\sigma:= \{\}$    // Empty variable assignment  \\
%\> for $x \in \mathit{Var}(\varphi)$: \\
%\>\>	if \= SAT($\varphi \land x$) = TRUE:  \\
%\>\>\> $\sigma := \sigma \cup \{x \mapsto 1\}$  \\
%\>\>\> $\varphi := \varphi \land x$  \\
%\>\>	else:  \\
%\>\>\> $\sigma := \sigma \cup \{x \mapsto 0\}$  \\
%\>\>\> $\varphi := \varphi \land \neg x$  \\
%\> return $\sigma$
%\end{tabbing}}
%
%The first observation is that the algorithm above runs in polynomial time wrt. the number of variables. In fact, the number of calls to the oracle are linear. The second one, is that it produces a valid assignment. Thirdly, a formula has no model if and only if it is unsatisfiable. Hence, the algorithm above detects all negative cases. Lastly, having weeded out the negative cases, it has to be established that the algorithm always finds a model. To that end consider a partial assignment $\sigma_{(x_1, \dots , x_i)}$ of the variables $x_1, \dots , x_i \in \mathit{Var}(\varphi)$ such that there exists an extension $\sigma_{(x_1, \dots , x_n)}$ under which $\varphi$ is satisfiable. Furthermore, consider the variable $x_{i+1}$. Due to the guarantee that $\sigma_{(x_1, \dots , x_n)} $ can be extended, it follows that if $\sigma_{(x_1, \dots , x_n)} \cup \{x_{i+1} \mapsto 1\}$ can no longer be extended to a satisfying assignment, then $\sigma_{(x_1, \dots , x_n)} \cup \{x_{i+1} \mapsto 0\}$ must be, and vice versa. This is precisely, what happens in the for loop. Meaning that at each step, the assignment is extended such that satisfiability is maintained. However, as the usual $\mathbf{SAT}$ problem does not take partial assignments as input, unit clauses are added, forcing a particular assignment of variables. \\
%
%
%Now using this observation and the fact that $\mathbf{FSAT}$ is $\mathbf{FNP}$-complete, one can use the following polynomial time transformation.
%\begin{itemize}
%\item $\mathbf{FSAT}$ is $\mathbf{FNP}$-complete.
%\item Any other $\mathbf{FNP}$-complete $\mathcal{P}_F$ can be reduced to $\mathbf{FSAT}$. 
%\item $\mathbf{FSAT}$ can be solved by a polynomial number of calls to a $\mathbf{SAT}$ oracle.
%\item However, $\mathbf{SAT}$ can be reduced to any other \NP-complete problem.
%\end{itemize}
%The other direction is trivial, i.e. similar as in the $\mathbf{SAT}$ case, the decision problem can be solved by solving the search problem.
%
%%Moving on to the more elementary proof.
%%
%%The class of \NP-complete can be understood as the class of all sets accepted b a non-deterministic Turing machine within a polynomial running time. Moreover, any \NP-complete problem $\mathcal{P}$, has a non-deterministic program (e.g. guess and check) that can decide given an input instance if this instance evaluates to true or to false. Such a program corresponds (Invariance Thesis) to a Turing machine $M_{\mathcal{P}}$ that decides this problem. Without loss of generality assume let all the Turing machines be over the alphabet $\{0,1\}$.
%%
%%
%%of the  exists an instance Meaning any problem $\mathcal{P} \in \NP-complete$ can by seen as the set of all accepting inputs.  
%
%\emph{Observation X:  $\FPNPlogwit  \subseteq  \FPNP$ }
%
% Consider an arbitrary problem $\mathcal{P}$ in \FPNPlogwit . Hence, there exists an algorithm $\mathcal{A}[\mathcal{Q}_F]$, that given an instance for $\mathcal{P}$, always returns a solution in polynomial time with a logarithmic number of calls to the witness oracle $\mathcal{Q}_F$. Meaning that $\mathcal{Q}_F$ is be some \textbf{FNP}-complete problem. Given the observation above, this oracle can be exchanged by its corresponding \NP-complete decision problem $\mathcal{Q}$ with just a polynomial time overhead. Let this algorithm be called $\mathcal{B}$. Hence, there resulting algorithm $\mathcal{A}'=\mathcal{A}[\mathcal{B}(\mathcal{Q})]$ is in \FPNP.
% 
% 
%\end{enumerate}
%%############################################## 
%\newpage    
%
%\item (10)  Let $\DP$ be the class of problems of the form 
%$A = A {\times} B$, where $A$ is a problem in $\NP$ and $B$ is a problem in $\coNP$.
%An instance $I=\tuple{I_1,I_2}$ of $A$ is a yes-instance iff $I_1$ and
%$I_2$ are yes-instances of $A$ resp.\ $B$. Intuitively, $I$ consists of
%the independent problems whose answers are connected by logical and.
%$\DP$ has complete problems, and the canonical one is {\bf SAT}${\times}${\bf UNSAT}.
%
%
%\begin{enumerate}[(a)]
%
%\item Show that the following problem is $\DP$-complete: given a
%  set $C = \{ C_1,\ldots, C_m\}$ of propositional clauses and a subset
%  $C'\subseteq C$, is it true that $C'$ is a {\em minimal unsatisfiable
%   subset}\/ of $C$, i.e., $C'$ is unsatisfiable but every proper
%  subset $C''\subset C'$ is satisfiable. 
%
%\item Consider how $\DP$ relates to $\NP \cap \coNP$ and to $\DeltaP{2}$.
%
%\end{enumerate}
%
%\item  (10) Consider Quantified Boolean Formulas (QBFs), but now not necessarily 
%       in prenex normal form, i.e., the quantifiers are not
%                            necessarily all at the beginning of the
%                            formula; e.g., the QBF
%       $F = \forall x, y[(x\lor y) \land \exists z(z \land y)]$.
%
%       \begin{enumerate}[(a)]
%                \item 
%       The {\em quantifier depth} $qd(F)$ of a QBF $F$ is recursively defined as
%       follows: 
%       $$qd(F)= \left\{
%       \begin{array}{ll}
%        0, & \text{if $F$ is an atom,} \\
%        \max(qd(F_1), qd(F_2)), & \text{ if $F= F_1 \;op\; F_2$,
%         for $op\in  \{ \land, \lor, \supset, \leftrightarrow \}$},  \\
%         qd(F_1), & \text{ if $F = \neg F_1$}, \\
%         qd(F_1)+1, & \text{ if $F = \exists x\,F_1$  or $F = \forall x\,F_1$}.
%       \end{array}\right.
%       $$
%       Analyze the complexity of deciding whether a given QBF $F$ with
%       $qd(F)=k$, where $k$ is a constant, evaluates to true.
%       
%       \item  The {\em alternation depth} $ad(F)$ of a QBF $F$ is,
%        informally, the maximum number of changes between quantifiers
%        $\exists$ and $\forall$ along any path in the formula tree
%         of $F$ from top to a leaf (i.e., an atom), plus 1. For the
%        formula $F$ above, we have $ad(F) = 2$.
%
%        \begin{enumerate}
%          \item Give a formal definition of alternation depth, in the
%            style of the one for quantifier depth.
%            
%           \item        Analyze the complexity of deciding whether a given QBF $F$ with
%       $ad(F)=k$, where $k$ is a constant, evaluates to true.
%        \end{enumerate}
%
% \end{enumerate}
%
%
%
%\item (5) Show formally that polynomial-time transformability is transitive,
% i.e., $A \lqm B$ and $B\lqm C$  implies $A \lqm C$. 
%
%Bonus: Try to establish the same for logspace-reductions.   
%
%\end{enumerate}
%
%\section{Default Logic}
%
%\begin{enumerate}[DL.1]
%
%\item (10) Reconsider Cautious Reasoning from default theories. Analyze
%what happens if all formulas  in $\tuple{W,D}$ are 
%      \begin{enumerate}
%          \item clauses, i.e., disjunctions
%                        $\ell_1\lor\cdots\lor\ell_k$ of literals $\ell_i$, 
%          \item terms, i.e., conjunctions $\ell_1\land\cdots\land \ell_k$ of literals $\ell_i$ 
%      \end{enumerate}
%       and the query formula $\phi$ is a literal $\ell$.
%                          
%\item (10) Consider Default logic, but this time the recognition
% problem for  extensions:
%
%{\bf DL RECOGNITION}
%
%INSTANCE: A default theory $T=\tuple{W,D}$ and a set $F=\{\}$ of formulas 
%
%QUESTION: Does $T$ have an extension $E$ such that $E=Cn(F)$?
%
%
%Consider this problem where all formulas in $T$ and in $F$ are 
%\begin{itemize}
%
%\item propositional Horn formulas; 
%\item arbitrary propositional formulas.
%\end{itemize}
%
%\item (10) Suppose your friend Jeff tells you that he has written an
% algorithm for constructing some default extension of a normal default
% theory using a SAT solver which  mostly terminates in short time
%  when the input formula is satisfiable, using the following scheme: 
%    \begin{enumerate}[(1)]
%     \item Initialize $E := W$ and $D' := D$; 
%     \item For every  $\frac{\alpha:\M\beta}{\beta} \in D$ do
%     \begin{enumerate}
%         \item If $E \cup \{ \neg \alpha \lor \beta \}$ is satisfiable then
%               continue,
%         \item   otherwise set $E := E \cup  \{ \beta\}$;    
%     \end{enumerate}
%    \item output $E$. 
%    \end{enumerate}
%Jeff claims that thanks to the SAT solver, the algorithm computes
%an extension very fast, where the output $E$ represents its closure $Cn(E)$.  Answer the following questions:
%\begin{enumerate}[(a)]
%      \item Is Jeff's algorithm correct? If not, is there an easy fix? 
%      \item Is this (corrected) algorithm really expected to perform very fast in
%            all cases?  If not, what could be bottlenecks or problems?  
%\end{enumerate}
%
%\item (10) A default theory $T=\tuple{W,D}$, may in general have multiple extensions. A
%natural question is then whether $T$ has a {\em unique extension},
%i.e., exactly one extension.  Analyze this problem (in the propositional
%case) for 
%
%\begin{enumerate}[(a)]
%
%\item normal $T$;
%
%\item normal and prerequisite-free $T$;
%
%\item arbitrary $T$.
%
%\end{enumerate}
%
%Aim at characterizations, or derive  reasonable bounds for the complexity.
%
%\item (10) Consider default theories $\tuple{W,D}$ of the form such that 
% $W$ consists of literals, and  all defaults are of the form 
%$\frac{p:~q}{\ell}$, where $p$ and $q$ are arbitrary atoms and $\ell$
%an arbitrary literal. 
%
%\begin{enumerate}[(a)]
%\item Analyze the complexity of deciding whether a given default theory of this
%form has an extension.  
%\item What happens if $W$ would be allowed to be a Krom theory?
%\end{enumerate}
%
%\item (10)   Consider a variant of default theories of the form $T=\tuple{W,D}$ where each
%default in $d \in D$ is of the form $d = \frac{\alpha~:}{\gamma}$,
%i.e., $d$ has no justifications. Such a default is then a {\em
%  monotonic rule}, and $T$ might be viewed as a monotonic rule
%system. 
%
%How difficult is it to decide whether 
%
%\begin{itemize}
%\item $T$ has an extension (defined as previously)?  
%\item $T$ has a consistent extension ? 
%\end{itemize}
%
%Aim at a complexity characterization, or give upper and lower bounds as good as possible.
%
%\item (10) {\em Disjunctive Default Logic}\/ (DDL) is a generalization of
%Reiter's  default logic in which default rules have  the form 
%$$\frac{\alpha\ :\ \M\beta_1,\ \M\beta_2,\,\ldots,\,\M\beta_n}{\gamma_1|
%  \gamma_2 | \cdots | \gamma_m},$$
%$n,m \geq 0$, and the $\gamma_i$ are alternative conclusions. 
%
%The definition of extension is similar: $E$ is an extension of 
%$T=\tuple{W,D}$, iff $E$ is a minimal (w.r.t.\ $\subseteq$) set $E'$ of formulas 
%such that 
%\begin{enumerate}
%\item $W\subseteq E'$;
%\item $E'$ is deductively closed, and 
%\item {\bf if}\ \
%                $\frac{\alpha\,:\,\M\beta_1,\,\ldots,\,\M\beta_n}{\gamma_1|
%  \gamma_2 | \cdots | \gamma_m}\in
%                D$ {\bf and} $\alpha\in E'$ and $\neg \beta_1\ldots\neg \beta_n\not\in E'$
%{\bf then} $\gamma_i\in E'$, 
%\end{enumerate}
%
%The need for DDL has been argued with insufficient treatment of disjunctive
%information in Reiter's DL; e.g., $T=\tuple{W,D}$ where 
%\begin{eqnarray*}
%W &=& \{ broken\_left \lor broken\_right  \}, \\
%D &=& \{\mbox{\normalsize$\frac{broken\_left \ :\ \neg usable\_left}{\neg
%    usable\_left},\quad  \frac{broken\_right \ :\ \neg usable\_right}{ \neg usable\_right},\quad \frac{~\top~:\ usable\_left, usable\_right}{fully\_ok}$} \} 
%\end{eqnarray*}
%($\top$ means a tautology) has a single extension in which $fully\_ok$ is contained;  if $
%broken\_left \lor broken\_right$ is replaced by the default 
%$\frac{~\top~:~}{broken\_left \,|\, broken\_right}$, the resulting DDL $T'$ has no
%extension which contains $fully\_ok$.
%
%\begin{enumerate}[(a)]
%\item Describe the extension of $T$ and $T'$ plus its extensions.
%
%\item Analyze the complexity of deciding whether a given propositional DDL theory
%$T=\tuple{W,D}$ has some extension, where $W=\emptyset$ and in the defaults all
%$\alpha$, $\beta_i$ and $\gamma_j$ are atoms.  
%
%What would change if $W$ would be a set of Horn clauses? 
%\end{enumerate}
%
%
%\item (10) As discussed in the lecture, deciding $\tuple{W,D}\models_b
%\ell$ for a literal $\ell$ is polynomial if $\tuple{W,D}$ is
%Literal-Horn i.e., $W$ is a set of literals and the defaults are
%``Horn'', i.e.\ of
%form
%$\frac{a_1\land\cdots\land a_k:\M \mu}{\mu}$, where the $a_i$'s are atoms and
%$\mu$ is a literal.  
%
%Consider what happens if all defaults are {\em dual Horn}, i.e.\ of form 
%$\frac{\neg a_1\land\cdots\land \neg a_k:\M \mu}{\mu}$, where the $a_i$'s are atoms and
%$\mu$ is a literal.
%
%\begin{enumerate}[(a)]
%
%\item Is the above reasoning problem then tractable, i.e., solvable in
%  polynomial time?
%
%\item  Is the
%problem solvable in {\bf LOG}, or in {\bf  NLOG} ?
%\end{enumerate}
%
%\item{(5)} Show that Cautious Default Reasoning is
%  $\PiP{2}$-hard, even for normal  default theories.
%      
%\end{enumerate}
%
%\section{Horn and Krom Formulas}
%\label{sec:HK}
%
%\begin{enumerate}[HK.1]
%
%\item (10) A {\em renaming} for a given a CNF $F$ on atoms $X$ is a subset
%$R\subseteq X$, and $F^R$ is the CNF in which the polarity of each 
%atom $a \in R$ in is flipped in $F$, i.e., $a$ is replaced by $\neg a$
%and $\neg a$ by $a$. 
%
%For example, let 
%$$F= (x_1 \lor x_2\lor x_3)\land (x_2\lor x_3)\land (\neg x_3
%     \lor \neg x_1).
%$$ 
%Then for the renaming  $R=\{x_1,x_2\}$, we have 
%$$F^R = (\neg x_1 \lor \neg x_2\lor x_3)\land (\neg x_2 \lor x_3)\land (\neg x_3
%                        \lor x_1). 
%$$                        
%Obviously, applying a renaming preserves satisfiability,
%i.e., $F^R$  is satisfiable iff $F$ is satisfiable. If renaming is
%cheap, it may be exploited for SAT solving.
%
%Analyze the complexity of this problem, i.e., to decide whether for a given
%CNF  there exists some $R$ such that $F^R$ is Horn. 
%                                
%\item (10) ``Horn renamings'' also establish an interesting link between Horn
%CNFs and Krom formulas: 
%
%\begin{itemize}
% \item[(*)]
% A Krom formula $F$ is
%satisfiable if and only if there is some renaming $R$ such that $F^R$ is
%a Horn formula.
%\end{itemize}
%For example, 
%$$F= (x_1 \lor x_2)\land (x_2\lor x_3)\land (\neg x_3
%     \lor \neg x_1).
%$$ 
%is satisfiable: e.g., assign true to $x_1$  and $x_2$ and false to
%$x_3$. For the corresponding $R=\{x_1,x_2\}$, we have that
%$$F^R = (\neg x_1 \lor \neg x_2)\land (\neg x_2 \lor x_3)\land (\neg x_3
%       \lor x_1) 
%$$                        
%is a Horn CNF. Prove the statement (*).
%
%\item (10) A Horn CNF $F$ is \emph{double-Horn},\/ if its negation
%  $\neg F$ is equivalent to some Horn CNF. E.g., $F= x_1 \land
%  x_2$ has this property. 
%
%  \begin{enumerate}
%  \item  Analyze the complexity of deciding whether a given Horn
%    formula $F$ is double-Horn
%
%  \item  Analyze the complexity of deciding whether a given CNF $F$ is
%    equivalent to some (arbitrary) double Horn CNF $F$ 
%  \end{enumerate}
%
%
%\item (10) Consider the following problems for Horn
%           formulas: 
%
%\begin{enumerate}[(a)]
%  \item Decide whether  given Horn CNFs $F$ and $G$ are
%                logically equivalent. 
%                
%  \item  Decide whether a given a Horn CNF $F$ is {\em prime}, i.e., each clause $c$ in $F$
%         is {\em prime}, that is, $F \not\models c'$ for each proper
%                subclause of $c$.
%
%  \item   Decide whether a given a Horn CNF $F$ is prime and
%          irredundant, i.e., no clauses can be removed from $F$ while
%          preserving equivalence.
%          
%\end{enumerate}
%
%Analyze the complexity of these problems, and provide bounds as good
%                as possible.
%
%\item (10) Consider the following problems for Krom
%           formulas: 
%
%\begin{enumerate}[(a)]
%  \item Decide whether  given Krom CNFs $F$ and $G$ are
%                logically equivalent. 
%                
%  \item  Decide whether a given a Krom CNF $F$ is {\em prime}, i.e., each clause $c$ in $F$
%         is {\em prime}, that is, $F \not\models c'$ for each proper
%                subclause of $c$.
%
%  \item   Decide whether a given a Krom CNF $F$ is prime and
%          irredundant, i.e., no clauses can be removed from $F$ while
%          preserving equivalence.
%          
%\end{enumerate}
%
%Analyze the complexity of these problems, and provide bounds as good
%                as possible.
%
%
%\item (10)  Consider the following problem: 
%
%{\bf GRAPH REACHABILITY}
%
%INSTANCE: A directed  graph $G=(V,E)$ and vertices $s,t\in E$
%
%QUESTION: Is there a directed path   $s=v_0 \rightarrow v_1\rightarrow
%     \cdots \rightarrow v_k=t$ in $G$? 
%
% \begin{enumerate}[(a)]
%  \item Show that {\bf GRAPH REACHABILITY} can be
%     transformed in logspace to the unsatisfiability problem of Krom
%    formulas. 
%                                
%  \item  Is this problem  {\bf  NLOG}-complete, if $G$ is known to be acyclic?
%
%  \end{enumerate}
%
%\item (10) Consider to decide whether a given CNF $F$ is equivalent to 
%  \begin{enumerate}[(a)]
%  \item some Horn formula 
%  \item some Krom formula
%  \end{enumerate}
%
%Analyze the complexity of this problem.
%
%\item (10) A model $M$ (satisfying assignment) of a Horn formula $F =
%  C_1\land\cdots\land C_m$ is called {\em supported}, if for every
%  atom
%  $x$ such that $x\in M$ (i.e., $x$ is true in $M$) there exists some
%  clause $C_i$ in $F$ such that $C$ is of the form  $x\lor C'$ and
%  $C'$ is not satisfied by $M$. E.g., the model $M=\{ x_1\}$
%  of $F = (x_1\lor \neg x_2)$  is supported, while $M=\{ x_1, x_2\}$ is not.
%
%Consider the following problem:
%
%{\bf  CS-HORN} 
%
%INSTANCE: Two Horn formulas $F_1$ and $F_2$ 
%
%QUESTION: Do $F_1$ and $F_2$ have some supported model in common? 
%
%\begin{enumerate}[(a)]
%\item Analyze the complexity of this problem
%\item What changes, if $F_1$ and $F_2$ are besides Horn also Krom?
%\end{enumerate}
%
%\item{(5)}  Determine whether {\bf UNIQUESAT} for input formulas $F$ (i.e., does $F$ has
%        exactly one satisfying assignment) is tractable/intractable for 
%        \begin{enumerate}[(a)]
%        \item  Horn formulas
%        \item  Krom formulas
%        \end{enumerate}
%
%\end{enumerate}
%
%
%\section{Closed World Reasoning}
%
%\begin{enumerate}[CW.1]
%
%\item (10) Give a formal proof that for a given propositional theory $T$,
%CWA($T$) is consistent if and only if $T$ has a single  $\leq$-minimal model $M$. 
%
%
%\emph{Observation 1: Let $T$ be a consistent propositional theory, $\mathit{CWA}(T)= T \cup \{ \neg p \mid p \in \mathit{Var}(T) , \,\exists \mathcal{M} \in \mathit{MMod}(T) \; \mathcal{M} \models \neg p \}$ }
%
%
%Consider the definition of the $\mathit{CWA}$, i.e. $\mathit{CWA}(T)= T \cup \{ \neg p \mid p \in \mathit{Var}(T) , \;T \nmodels p \}$.
%By semantics of entailment one obtains the equality 
%\begin{equation*}
% \{ \neg p \mid p \in \mathit{Var}(T), \;T \nmodels p \} = \{ \neg p \mid p \in \mathit{Var}(T), \, \exists \mathcal{M} \in \mathit{Mod}(T) \; \mathcal{M} \models \neg p \}.
%\end{equation*}
%Now, consider the definition of subset minimality. That is, for the two models $\mathcal{I}$ and $\mathcal{I}'$ of a formula $\chi$, $\mathcal{I}' \leq \mathcal{I}$ iff $\mathcal{I}' \subseteq \mathcal{I}$ iff $\forall p \mathit{Var}(\chi) \; \mathcal{I}' \models p \Rightarrow  \mathcal{I} \models p$. Hence, if there exists a model $\mathcal{M}$ such that $\mathcal{M} \models \neg p$ then there must be a minimal model $\mathcal{M}'$ also satisfying $\neg p$. Therefore, 
%\begin{equation*}
%\{ \neg p \mid p \in \mathit{Var}(T), \, \exists \mathcal{M} \in \mathit{Mod}(T) \; \mathcal{M} \models \neg p \} = \{ \neg p \mid p \in \mathit{Var}(T), \, \exists \mathcal{M} \in \mathit{MMod}(T) \; \mathcal{M} \models \neg p \}
%\end{equation*}
%Hence, arriving at
%\begin{equation*}
%\mathit{CWA}(T)= T \cup \{ \neg p \mid p \in \mathit{Var}(T), \, \exists \mathcal{M} \in \mathit{MMod}(T) \; \mathcal{M} \models \neg p \}
%\end{equation*} \\
%
%\emph{Observation 2: If $T$ is a satisfiable propositional theory such that $\mathit{MMod}(T):= \{\mathcal{M}_m\}$, then $CWA(T)$ is consistent.}
%
%From Observation 1, one obtains that $\mathit{CWA}(T)= T \cup \{ \neg p \mid p \in \mathit{Var}(T), \, \exists \mathcal{M} \in \mathit{MMod}(T) \; \mathcal{M} \models \neg p \}$, which given the assumption about $T$ gives the equality
%\begin{equation*}
%\mathit{CWA}(T)= T \cup \{ \neg p \mid p \in \mathit{Var}(T), \; \mathcal{M}_m \models \neg p \}
%\end{equation*} 
%Clearly, $\mathcal{M}_m$ satisfies both $T$ and $ \{ \neg p \mid p \in \mathit{Var}(T),  \; \mathcal{M}_m \models \neg p \}$. Hence, by semantics it $\mathcal{M}_m$ satisfies the union of those sets. Therefore, $\mathcal{M}_m$ is a model of $\mathit{CWA}(T)$, thus establishing consistency. \\
%
%
%\emph{Observation 3: If $T$ is a satisfiable propositional theory such that $|\mathit{MMod}(T)| > 1$, then $CWA(T)$ is inconsistent.}
%
%From Observation 1, one obtains that $\mathit{CWA}(T)=T \cup \{ \neg p \mid p \in \mathit{Var}(T), \, \exists \mathcal{M} \in \mathit{MMod}(T) \; \mathcal{M} \models \neg p \}$. Hence, for any model $\mathcal{M}_{CWA}$ of  $\mathit{CWA}(T)$ it must be that 
%\begin{equation*}
%\mathcal{M}_{CWA} \cap \{ p \mid p \in \mathit{Var}(T), \, \exists \mathcal{M} \in \mathit{MMod}(T) \; \mathcal{M} \models \neg p \} = \emptyset
%\end{equation*} 
%Thus implying that 
%\begin{equation*}
%\mathcal{M}_{CWA} \subseteq \mathit{Var}(T)  \setminus \{ p \mid p \in \mathit{Var}(T), \, \exists \mathcal{M} \in \mathit{MMod}(T) \; \mathcal{M} \models \neg p \} 
%\end{equation*} 
%which is equivalent to 
%\begin{equation*}
%\mathcal{M}_{CWA} \subseteq \{ p \mid p \in \mathit{Var}(T), \,  \forall \mathcal{M} \in \mathit{MMod}(T) \; \mathcal{M} \models  p \} 
%\end{equation*} 
%Now consider the set $\{p \in \mathit{Var}(T) \mid  \forall \mathcal{M} \in \mathit{MMod}(T) \; \mathcal{M} \models  p\}$ this is the same as considering the intersection $\mathcal{M}_{\cup} := \bigcap_{\mathcal{M} \in \mathit{MMod}(T)} \mathcal{M}$. However, there are at least two distinct minimal models $\mathcal{M}_1$ and $\mathcal{M}_2$. However, it is clearly the case that $\mathcal{M}_{\cup} \subset\mathcal{M}_1 $ and $\mathcal{M}_{\cup} \subset\mathcal{M}_2 $. Hence, if $\mathcal{M}_{\cup}$ would be a model of $T$, minimality of  $\mathcal{M}_1$ and $\mathcal{M}_2$ would be violated. Hence, $\mathcal{M}_{\cup} $ as well as any subset of it, can not be a model of $T$
%Thus only the interpretations $\mathcal{M}' \subseteq \mathcal{M}_{\cup}$ can model $ \{ \neg p \mid p \in \mathit{Var}(T), \, \exists \mathcal{M} \in \mathit{MMod}(T) \; \mathcal{M} \models \neg p \}$, while at the same time they can not be models of $T$. Hence, no model can satisfy $\mathit{CWA}(T)$, thereby rendering it inconsistent. \\
%
%
%By negating Observation 3 one obtains "For $T$ being a satisfiable propositional theory. If $\mathit{CWA}(T)$ is consistent, then $|\mathit{MMod}(T)| =1$.". Together with Observation 2 one therefore obtains that, given a satisfiable propositional theory $T$, $\mathit{CWA}(T)$ is consistent if and only if $T$ has a single  $\leq$-minimal model $\mathcal{M}$. 
%Lastly, assume that $T$ is not satisfiable, then trivially $\mathit{CWA}(T)$ can not be consistent and $|\mathcal{MMod}(T)|=|\emptyset|\neq 1$.  Hence, allowing for arbitrary propositional theories, and thus the required claim is established. 
%
%\newpage 
%
%
%\item (10) Analyze the complexity of deciding whether CWA($T$) is
%   consistent for the case where 
%   \begin{enumerate}
%        \item each formula in $T$ is a Krom CNF
%        \item each formula in $T$ is a Horn CNF
%        \item each formula in $T$ is Horn renameable (see Section~\ref{sec:HK}).
%   \end{enumerate}
%
%   Provide bounds / characterizations as good as possible.
%
%\item (10) As shown in the lecture, deciding $MM(T)\models \neg
%x$ for a propositional theory $T$ and an atom $x$ is
%$\PiP{2}$-hard. 
%    \begin{enumerate}[(a)]
%
%        \item What is the complexity of deciding
%    $MM(T)\models x$ (where $x$ is an atom)
%    
%    \item What is the complexity of deciding ECWA$(T;P;Z)\models x$? 
%    
%    \item Related to this, has inference of
%    positive and negative literals from $P;Z$-minimal models  the same
%    complexity?  
%    \end{enumerate}
%
%\item (10) As discussed in the lecture, the semantics of a disjunctive logic
%program $P$ with rules of the form
%\begin{equation}
%\label{clause}
%a_1\lor \cdots \lor a_m \leftarrow b_1, \ldots, b_n,\quad m \geq 1, n\geq 0,
%\end{equation}
%where all $a_i$ and $b_i$ are propositional atoms, should be the minimal
%models of the propositional theory $T(P)$ where each rule (\ref{clause})
%in $P$ is replaced with $\neg b_1 \lor \neg b_2 \lor\cdots \lor \neg b_n
%\lor a_1\lor \cdots \lor a_m$; inference of a formula $F$ from $P$,
%$P\models_{mm} F$, is defined by $\mm{T(P)} \models F$.
%
%A {\em disjunctive fact} is a rule (\ref{clause}) where $m>1$ and $n=0$,
%which corresponds to a positive clause; it is a {\em disjunctive conclusion}\/ of $P$, if 
%$P\models_{mm} a_1\lor \cdots \lor a_m$ and 
%no $a'_1\lor \cdots\lor a'_l$ with 
%$\{a'_1,\ldots, a'_l\} \subset \{a_1,\ldots,a_m\}$ exists such that
%$P\models_{mm} a'_1\lor \cdots\lor a'_l$.
%
%E.g., for the smoker program in the lecture, 
%$\textit{good} \lor \textit{bad}$ is a disjunctive conclusion, while 
%$\textit{smoke} \lor \textit{angry}$ is not (as $P \models_{mm} \textit{smoke}$).
%
%Consider the following problems: 
%
%\begin{enumerate}
%\item Given a propositional disjunctive program $P$, does there exist
% some disjunctive conclusion for $P$? 
%
%\item Given a propositional disjunctive program $P$ and a set of atoms $A$, does there exist
% some disjunctive conclusion $a_1\lor \cdots \lor a_m$ for $P$ 
%such that $\{a_1,\ldots,a_m\} \subseteq A$?
%\end{enumerate}
%
%Characterize the complexity of these problems, or give bounds as good as possible.
%
%Bonus: how does the result change if we ask  for a unique disjunctive
%conclusion? 
%
%\item (10)  Consider theories $T$ which are in clausal form. They can be
%     split into a Horn part $T_H$ and a non-Horn part $T_N$
%     ($T = T_H \cup T_N$).  
%      
%      Single out some condition(s) on $T_N$ under which deciding
%      inferences       
%      \begin{enumerate}
%             \item $\mm{T} \models x$
%             \item $\mm{T} \models \neg x$
%      \end{enumerate}
%      where $x$ is an atom, is polynomial (lim at having this condition liberal)
%            
%\item (10) A variant of the CWA is the following {\em Partial Closed
%    World Assumption (PCWA)}:  Given a (propositional) theory $T$ and a set of atoms
%  $P$, let 
%$$
%\textrm{PCWA}(T;P) = T \cup \{ \neg A \mid A \in P, T \not \models A \}
%$$
%Analyze the following problems, and derive complexity bounds as good
%as possible: 
%
%\begin{enumerate}[(a)]
%\item Decide, given a theory $T$ and a set of atoms $P$, whether PCWA$(T;P)$ is consistent.
%\item Decide, given a theory $T$, a set of atoms $P$, and a
%  propositional formula $F$, whether PCWA$(T;P)\models F$.
%\end{enumerate}
%
%\item (10) 
%Suppose $F$ is a CNF and that $M_1,\ldots,M_k$ are minimal models
%$F$. Analyze the complexity of deciding, given $F$ and $M_1,\ldots,M_k$,
%whether  $\mm{F} = \{ M_1,\ldots,M_k\}$, i.e., no further minimal model of $F$ exists.
%
%What happens if $F$ is a Krom CNF? 
%
%
%Bonus: determine the same for $P;Z$-models.
%
%
%\item (10) Analyze the complexity of Model Checking for ECWA in the Krom 
%case: Given a Krom theory $T$,  partition $\tuple{P;Q;Z}$  of the
%atoms, and an interpretation $M$, the question is whether $M$ is a
%model of $\mbox{ECWA}(T)$. 
%
%\begin{enumerate}[(a)]
%       \item Consider this problem for the case of arbitrary $\tuple{P;Q;Z}$. 
%       \item Consider specializations where some of $P$, $Q$, and $Z$
%             are empty. Single out cases where the problem is
%             tractable. 
%  
%       \item  Which are the maximal tractable cases (i.e., no empty
%              $P$, $Q$, or $Z$ can be made nonempty without losing tractability).
%             
%\end{enumerate}
%
%
%\item {(5)} Show that
%
% \begin{enumerate}[(a)]
%  \item GCWA$(T)\models F$ implies that EGCWA$(T)\models F$, but not
% vice versa, and similarly that
%\item CCWA$(T)\models F$ implies ECWA$(T)\models F$ but not vice
%  versa.
%\end{enumerate}
%Give in both cases counterexamples which demonstrate the failure of
%the converse.
%
%\end{enumerate}
%
%
%\section{Theory Change and Counterfactual Reasoning}
%
%Let {\bf CF}$_X$ denote the problem {\bf CF} for
%change operator $X$, i.e., deciding whether $T\models \phi >_X \psi$
%(by the Ramsey test, $T \circ_X \phi\models \psi$).
%
%\begin{enumerate}[TCR.1]
%
%\item (10) Consider the following operator $\circ_{Win}$ for updating a
%      theory $T$ (known as Winslett's Possible Model Approach): 
%\[
%\begin{array}{r@{}l@{~}l}
%Mod&(T\circ_{Win} \phi) =& \\
%                 & \bigcup_{M \in Mod(T)}\{M' \in Mod(\phi)
%                        \mid & \forall M'' \in
%Mod(\phi):\\
%&&  M\triangle M''\subseteq  M \triangle M' \Rightarrow M'=M''\}
%\end{array}
%\]      
%where ``$\triangle$'' denotes symmetric set difference. 
%
%Analyze the complexity of CF$_{Win}$, i.e., given $T$, $\phi$, and
%$\psi$, decide whether $T \models \phi>\psi$. To this end, provide
%(a) an upper bound and  (b) a lower bound as good as possible.
%
%Bonus: Can these bounds be changed when it is known
%that $T$ respectively $\phi$ has only $O(n)$ many models, where $n$ is the number of
%different atoms occurring in $T$ resp.\ $\phi$? 
%
%
%\item (10) We can define the change recognition problem for Ginsberg's operator
%  follows: Given a (possibly inconsistent) propositional theory $T$, a
%  satisfiable formula $\phi$, and a theory $T'$, decide whether $T' = 
%  T'' \cup\{ \phi \}$ for some $T'' \in W(\phi,T)$. 
%
%  Analyze the complexity of this problem for 
%
% \begin{enumerate}[(a)]
% \item arbitrary $T$ 
% \item Horn $T$
% \item Krom $T$
% \end{enumerate}
%
%Hint: recall the complexity class $D^P = \{ L  \mid L = L_1 \times L_2,
%L_1 \in \NP, L_2 \in  \coNP \}$ from the lecture.
%
%\item (10) Consider model checking for Dalal's operator:
%  Given a (possibly inconsistent) propositional theory $T$, a
%  satisfiable formula $\phi$, and an interpretation $M$, does $M \in
%  \Mod{T \circ_D \phi}$ hold? Analyze the complexity of this problem for 
%
% \begin{enumerate}[(a)]
% \item arbitrary propositional $T$ and $\phi$
% \item Horn $T$ and $\phi$
% \end{enumerate}
%
%\item  (10) Analyze the complexity of the problem {\bf CF}$_{X}$,
%                        for one $X\in \{ G, D\}$, for  the
%      Krom case, i.e., all formulas in $T$ and $\phi,\psi$ are Krom CNFs. 
%
%Bonus: What happens if $\phi$ and $T$ share few (bounded by a constant
%                        $k$ many) variables?
%
%\item (10) (Minimal Conflict Set) An important notion in
%  diagnosis are minimal conflict sets: 
%
%Given a set $S$ of formulas, a {\em minimal conflict set} of $S$ is a set
%$S'\subseteq S$ of formulas such that $(i)$ $S'$ is unsatisfiable
%and $(ii)$ $S'$ is minimal under inclusion, i.e., no proper subset
%$S''\subset S'$ satisfies property $(i)$. 
%
%Analyze the complexity of the following problems: Given a set $S$ of
%propositional formulas and a
%formula $\phi$, decide whether \begin{inparaenum}[(a)]\item $\phi$ belongs to some minimal conflict set of $S$,  
%\item $\phi$ belongs to every minimal conflict set of $S$.  
%\end{inparaenum}
%
%Bonus: Under which (non-trivial) conditions is this problem solvable in
%polynomial time?
%
%\item (10) (Paraconsistency) Given a set $T$ of propositional formulas, 
%call $C=(T_1,\ldots,T_n)$, $n\geq 1$, a {\em consistent
%covering} of $T$, if 
%\begin{inparaenum}[(i)]
%\item $T_i \cap T_j = \emptyset$ for all $1\leq i < j\leq n$,
%\item~ $\bigcup_{i=1}^n T_i = T$, and
%\item each $T_i$ is satisfiable;
%\end{inparaenum}
%the \emph{size}\/ of $C$ is $n$.
%
%The \emph{level}\/ of $T$, $\lambda(T)$, is  the smallest number $n$ such that 
%some consistent covering  $C$ of size $n$ exists, and $\infty$ otherwise.
%Note that $\lambda(T) = \infty$ iff $T$ contains an unsatisfiable
%formula, and  $\lambda(T)=1$ iff $T$ is satisfiable.
%
%Define a consequence relation $T \models^p \phi$, where $\phi$ is a 
%formula as follows: $T\models \phi$ holds, if either $\lambda(T) =
%\infty$, or for each consistent covering  $C=(T_1,\ldots,T_n)$  of $T$ of size $n=\lambda(T)$, there
%exists some $i$ such that $T_i\models \phi$. 
%
%E.g., for $T = \{ a,\ b,\ \neg a \lor \neg b, c \supset d\}$, $\lambda(T)=2$ and $T \models^p
%c \supset d$, $T\models^p a \lor b$, $T\not\models^p \neg a$, $T\not\models^p \neg b$.
%
%Analyze the complexity of $T\models \phi$. 
%
%
%
%%######################################################################
%
%
%
%
%
%\newpage
%
%\item{(10)} Show that {\bf CF}$_G$ is $\PiP{2}$-hard by a reduction from
%  Closed World Reasoning under the EGCWA, i.e., from EGCWA$(T)\models F$
%  (which has the same complexity). Provide also a reduction in the other
%  direction, i.e., from deciding EGCWA$(T)\models F$ to {\bf CF}$_G$.
%
%Bonus: Consider the use of ECWA$(T;P;Z)$ in place of EGCWA$(T)$.\\
%
%Firstly, $\textbf{CF}_G$ is the problem of deciding whether for some theory $T$ and two formulas $\varphi$ and $\psi$, $T\models \psi >_G \varphi$ holds. Which again is merely a shorthand for $T \circ_G \psi \models \varphi$. This leading to the definition of the two problems at hand.
%
%$T \circ_G \psi \models \varphi	$ is equivalent to $ \{T' \cup \{\psi\} \mid T' \in W(\psi,T)\} \models \varphi$. Leading the completely unwrapped definition of 
%\begin{equation*}
%\{T' \cup \{\psi\} \mid T' \in  \max_{\subseteq}\{ T'' \subseteq T : T'' \nmodels \neg \psi\} \} \models \varphi
%\end{equation*}
%That is, $W(\psi,T)$ is the set of maximal sub-theories of $T$ that are consistent with $\psi$.
%Hence, $T \circ_G \psi \models \varphi	$ expresses that all maximal $\psi$-consistent sub-theories of $T$ entail $\varphi$. \\
%
%By contrast, $\mathit{EGCWA}(T) \models \varphi$ is equivalent to  
%\begin{equation*}
%T \cup \{\neg C \mid C \mathit{ \; conjunction \; of \; } a \in \mathit{Var}(T) , \;  \mathit{MMod}(T) \models \neg C  \} \models \varphi
%\end{equation*}
%with $\mathit{MMod}(T) \models \psi$ expressing that all minimal models wrt. positive information ($M \in \mathit{MMod}(T) \land M \subseteq M' \implies (\sigma_M(x)=1 \Rightarrow \sigma_{M'}(x)=1 )$) entail $\psi$.\\
%
%Starting with the reduction $\mathit{EGCWA}(T) \models \varphi  \leq_m^P \textbf{CF}_G $ for input $\tau(T,\varphi)$, where $\tau$ is defined as
%\begin{equation*}
%\tau(T, \varphi)  =  (A, T_{\land}, \varphi) = (\{ \neg x \mid \forall x \in \mathit{Var}(T)\}, \bigwedge_{\psi \in T} \psi, \varphi)
%\end{equation*}
%meaning that one obtains the problem $ A \circ_G T_{\land} \models \varphi$. \\
%
%\emph{Observation 1: If $T$ is satisfiable, then for $A \in W \big( \{ \neg x \mid \forall x \in \mathit{Var}(T)\} ,  \bigwedge_{\varphi \in T} \varphi \big)$, there exists exactly one model $\mathcal{M}$, such that $\mathcal{M} \models A \cup T$. \\}
%
%
%Any model satisfying $A$ must evaluate all variables in $A$ as $0$. Let $\mathcal{M}_A := \{ x \mapsto 0 \mid \forall x \in \mathit{Var}(A)  \} \cup  \{ x \mapsto 1 \mid \forall  x \in \mathit{Var}(T) \setminus \mathit{Var}(A) \}$. Clearly, $\mathcal{M}_A$ models $A$ and by construction $\mathcal{M}_A \nmodels \neg   \bigwedge_{\varphi \in T} \varphi $. If there would be another model $\mathcal{M}$ such that for some variable $c$, one has $\sigma_{\mathcal{M}}(c)=0$ and $\sigma_{\mathcal{M}_A}(c)=1$, for which  $\mathcal{M} \nmodels \neg   \bigwedge_{\varphi \in T} \varphi $ holds. One has found $A  \cup \{\neg c\}$ such that  $A  \cup \{\neg c\} \nmodels \neg   \bigwedge_{\varphi \in T} \varphi$, which clearly contradicts the maximality of $A$.  Therefore,  $\mathcal{M}$ can not satisfy $T$. \\
%
%Clearly, if 
%
%\emph{Observation 2: For a given theory $T$, 
%\begin{equation*}
%\mathit{MMod}(T)=\{\mathcal{M} \mid \forall A \in W \big( \{ \neg x \mid \forall x \in \mathit{Var}(T)\} ,  \bigwedge_{\varphi \in T} \varphi \big) \forall \mathcal{M} \; \mathcal{M} \models A \cup T\}
%\end{equation*}}
%%\{\mathcal{M}  \mid \exists A \in  \max_{\subseteq} \big\{ A' \subseteq  \{ \neg x \mid \forall x \in \mathit{Atom}(T)\} : A' \nmodels \neg  \bigwedge_{\varphi \in T} \varphi  \big\} \; \mathcal{M}  \models A \cup T\}
%%\{\mathcal{M} \mid \exists A \subseteq_{max} \{ \neg x \mid \forall x \in \mathit{Atom}(T)\} \; \big( \mathcal{M} \models \bigwedge_{\varphi \in A} \varphi \mathit{\; and \; } \mathcal{M} \models  \bigwedge_{\varphi \in T}   \varphi \big)\}
%
%If $T$ is not satisfiable, clearly 
%\begin{equation*}
%\mathit{MMod}(T) = \emptyset = \{\mathcal{M} \mid \forall A \in W \big( \{ \neg x \mid \forall x \in \mathit{Var}(T)\} ,  \bigwedge_{\varphi \in T} \varphi \big) \forall \mathcal{M} \; \mathcal{M} \models A \cup T\}
%\end{equation*}
%
%
%$" \Rightarrow "$: Take $\mathcal{M} \in \mathit{MMod}(T)$. Clearly, $\mathcal{M}$ models $T$ and thus $\mathcal{M} \nmodels  \neg \bigwedge_{\varphi \in T}   \varphi$. Using the induced assignment  $\sigma_{\mathcal{M}}$ construct $A_{\mathcal{M}}:= \{ \neg x \mid \forall x \in \mathit{Var}(T)\; \sigma_{\mathcal{M}}=0 \}$, which is satisfied by $\mathcal{M}$ by construction. Hence, it remains to show that $A_{\mathcal{M}}$ is maximal. Assume that there exists a  $A_{\mathcal{M}'} \supset A_{\mathcal{M}}$, such that $\mathcal{M}'$ satisfies $T$ . Hence, there exists $x$, such that $\sigma_{\mathcal{M}'}(x)=0$, while $\sigma_{\mathcal{M}}(x)=1$. However, this contradict the minimality of $\mathcal{M}$. 
%
%
%$" \Leftarrow "$: Take $\mathcal{M}_A \in\{\mathcal{M} \mid \forall A \in W \big( \{ \neg x \mid \forall x \in \mathit{Var}(T)\} ,  \bigwedge_{\varphi \in T} \varphi \big) \forall \mathcal{M} \; \mathcal{M} \models A \cup T\}$. 
%By construction $\mathcal{M}_A$ models $T$. It remains to show that $\mathcal{M}_A$ is minimal. Since, $A$ contains the maximal amount of negative literals such that $T$ is not contradicted (see observation 1), any model $\mathcal{M} \subset  \mathcal{M}_A$ can not be a model of $T$. Therefore, $\mathcal{M}_A$ is a minimal model of $T$.
%
%
%Since $\mathcal{M} \models A \cup T$ is unique the one could rewrite the statement to: for a given theory $T$, 
%\begin{equation*}
%\mathit{MMod}(T)=\{\mathcal{M}_A \mid \forall A \in W \big( \{ \neg x \mid \forall x \in \mathit{Var}(T)\} ,  \bigwedge_{\varphi \in T} \varphi \big) \; \mathcal{M}_A \models A \cup T\}
%\end{equation*}
%
%Using those observation one obtains the following. 
%
%Assume that $\mathit{EGCWA}(T) \models \varphi$. Hence, $\forall \mathcal{M} \in \mathit{Mod}(\mathit{EGCWA}(T)) \; \mathcal{M} \models \varphi$, which given the theorem in the lecture slides, is equivalent to $\forall \mathcal{M} \in \mathit{MMod}(T) \; \mathcal{M} \models \varphi$. Now using the observation 2 one obtains the equivalent statement $\forall \mathcal{M} \in  \{\mathcal{M}_A \mid \forall A \in W \big( \{ \neg x \mid \forall x \in \mathit{Var}(T)\} ,  \bigwedge_{\varphi \in T} \varphi \big) \; \mathcal{M}_A \models A \cup T\}  \; \mathcal{M} \models \varphi$, which is equivalent to $  \{ \neg x \mid \forall x \in \mathit{Var}(T)\}  \circ_G   \bigwedge_{\psi \in T} \psi  \models \varphi$. \\
%
%Secondly, the reduction $\mathit{KB} \circ_G \psi \models \varphi     \leq_m^P \mathit{EGCWA}(T) \models \varphi $, where $\tau$ is defined as $\tau(KB, \psi)  = (T, \psi) $ with $T$ being 
%\begin{equation*}
%\{\psi\} \cup \{ x_i \not\equiv y_i  \mid \forall x_i \in \mathit{Var}(\mathit{KB}  \cup \{\psi\})\} \cup 
% \left\lbrace  d_i    \lor \chi_i  \mid \forall \chi_i \in \mathit{KB} \right\rbrace 
%\end{equation*}
%with $d_i := \big( \bigwedge_{j=0}^{|\mathit{Var}(\chi_i)|} z_{ij} \big)$, where $y_i, z_{ij}$ are some fresh propositional variables (including the variables in $\varphi$).  
%As a shorthand let $T_{y}:=\{ x_i \not\equiv y_i  \mid \forall x_i \in \mathit{Var}(\mathit{KB}  \cup \{\psi\})\} $ and let $T_z:=\left\lbrace  \big( \bigwedge_{j=0}^{|\mathit{Var}(\chi_i)|} z_{ij} \big)    \lor \chi_i  \mid \forall \chi_i \in \mathit{KB} \right\rbrace $ \\
%
%
%\emph{Observation 1:  $\mathit{MMod}(T_y) = \mathit{Mod}(T_y)$. } 
%
%Clearly $\mathit{MMod}(T_y) \subseteq \mathit{Mod}(T_y)$. Consider $\mathcal{M} \in \mathit{Mod}(T_y)$ assume that there exists a $\mathcal{M}' \subset \mathcal{M}$. Hence, $\exists z \in \mathcal{M}\; z \notin \mathcal{M}'$. However, w.l.o.g. assume that $z=x_i$ then $\sigma_{ \mathcal{M}'}(x_i)=0$ However, this requires through $x_i \neq y_i$ that $\sigma_{ \mathcal{M}'}(y_i) = 1$ and thus $y_i \in \mathcal{M}'$. 
%Clearly, $y_i \notin \mathcal{M}$. Hence, $\mathcal{M}' \not\subset \mathcal{M}$. Thus, $\mathcal{M}$ is minimal, i.e. $\mathcal{M} \in \mathit{MMod}(T_y)$ \\
%
%%
%%\emph{Observation 2:  $\{ \{ \chi \mid \forall \chi \in \mathit{KB} \; \mathcal{M} \models \chi\}\mid \forall \mathcal{M} \in \mathit{MMod}(T_z \cup \{ \psi\})\}= W(\psi, \mathit{KB})$. } 
%%
%%
%% Let $U=\{ \{ \chi \mid \forall \chi \in \mathit{KB} \; \mathcal{M} \models \chi\}\mid \forall \mathcal{M} \in \mathit{MMod}(T_z\cup \{ \psi\})\}$.
%% 
%%$"\subseteq"$: Take a $T' \in U$. Hence, there exists a  $\mathcal{M} \in \mathit{MMod}(T_z\cup \{ \psi\})$ which satisfies every $\chi_i \in T'$ consistent with $\psi$. Now with $\mathcal{M}$ being a minimal model, it is not possible that $d_i$ and $\chi_i$ are satisfied. By construction satisfying $\chi_i$ is less expensive than satisfying the corresponding $d_i$ in the disjunction $d_i \lor \chi_i$. Therefore, $\mathcal{M}$ satisfies a minimal amount of $d_i$'s, while still satisfying $\psi$. That is, under $\mathcal{M}$ a maximal amount of $\chi_i$ are satisfied, such that satisfying any additional $\chi_j$ would lead to $\neg \psi$ being satisfied, i.e. $\mathcal{M} \nmodels \neg \psi$, but $(\mathcal{M}  \cup \{ \chi_j\}) \setminus \{d_j\} \models \neg \psi$. Hence, $T'$ is a maximal subset of $KB$ such that $\mathcal{M} \nmodels \neg \psi$ and therefore $T' \in  W(\psi, \mathit{KB})$. (Note: Clearly, there are non-minimal models satisfying $T'$, however, since there exists one model, the minimal one, where $\psi$ is satisfied, the case $T' \models \neg \psi$ is not possible.)
%%
%%
%%$"\supseteq"$: Take a $\mathit{KB}' \in W(\psi, \mathit{KB})$. Meaning that $ \mathit{KB}'$ is a maximal subset of $ \mathit{KB}$ such that $ \mathit{KB}' \nmodels \neg \psi$. Hence, for all models $\mathcal{M} \models  \mathit{KB}'$ there exists at least one, let it be $\mathcal{M}$, such that $\mathcal{M} \models \psi$ and while being minimal. Let $\mathcal{M}_d$ be the model $\mathcal{M}$ extended such that for any $\chi_i$ not satisfied under $\mathcal{M}$, $d_i$ in the disjunction $d_i \lor \chi_i$ of $T'$ must be satisfied. 
%%Since adding an additional formula from $\mathit{KB}$ to $\mathit{KB}'$ would lead to an inconsistency with $\psi$, $\mathcal{M}_d$ will only satisfy the $\chi_i$ in $d_i \lor \chi_i$, if $\chi_i \in \mathit{KB}'$ and due thus a maximal amount of $\chi_i$'s are satisfied. Therefore, a minimal amount of $d_i$ is satisfied under $\mathcal{M}_d$. Since $\mathcal{M}$ used a minimal amount of variables to satisfies all $\chi$, $\mathcal{M}_d$ is a minimal model of $T_z \cup \{\psi\}$, thus $\mathit{KB}' \in U$.
%
%
%Observation 2: There exists a bijection $\pi$ from $\bigcup_{\mathit{KB}' \in W(\psi, \mathit{KB})} Mod(\mathit{KB}' \cup \{\varphi\})$ to $\mathit{MMod}(T)$. Where $\pi(\mathcal{M}_K)=\mathcal{M}_T$ with $\mathcal{M}_T$ being
%\begin{equation*}
%\mathcal{M}_K \cup \{y_i \mid \forall (x_i \not\equiv y_i) \in T_y \; x_i \notin \mathcal{M}_K\} \cup
% \{ z_{ij} \mid \forall (d_i \lor \chi_i) \in T_z  \forall z_{ij} \in \mathit{Var}(d_i) \; \mathcal{M}_K \nmodels \chi_i\}
%\end{equation*}
%where its inverse is simply the restriction of $\mathcal{M}_T$ to the variables in $\mathit{Var}(\mathit{KB} \cup \psi)$.
%
%
%First, it has to be demonstrated that $\mathcal{M}_T$ is actually a minimal model. Let $\mathcal{M}_K$ be an arbitrary model of $\mathit{KB}' \cup \{\varphi\}$  for some $\mathit{KB}' \in W(\psi, \mathit{KB})$. Clearly, $\mathcal{M}_K \cup \{y_i \mid \forall (x_i \not\equiv y_i) \in T_y \; x_i \notin \mathcal{M}_K\}$ satisfies $T_y$. By Observation 1, it follows that it is minimal. Hence, it is from now on only relevant, if a $\chi_i$ is satisfied, and not how it is satisfied. Speaking of which, since $\mathit{KB}'$ is a maximal subset of $\mathit{KB}$ that is still consistent with $\psi$, the case $\mathcal{M}_K \models \chi$ where $\chi \notin \mathit{KB}$, but $\chi \notin \mathit{KB}'$ can not arise. Therefore, the set $\{\chi_i \mid \forall \chi_i \in \mathit{KB} \mathcal{M}_K \models \chi_i\}$ is maximal. Therefore, $\{\chi_i \mid \forall \chi_i \in \mathit{KB}  \mathcal{M}_K \nmodels \chi_i\}$ is minimal. Hence, only a minimal amount of $d_i$'s is satisfied, i.e. $ \{ z_{ij} \mid \forall (d_i \lor \chi_i) \in T_z  \forall z_{ij} \in \mathit{Var}(d_i) \; \mathcal{M}_K \nmodels \chi_i\}$ is minimal. Since, $d_i$ is only satisfied, if $\chi_i$ is not modelled by $\mathcal{M}_K$ and vice versa, $\mathcal{M}_T$ is minimal model of $T$. \\
%
%Secondly, one has to demonstrate that $\pi$ is surjective. Assume that there exists a model $\mathcal{M}_T \in \mathit{MMod}(T)$ and that there exists no $\mathcal{M}_K \in \bigcup_{\mathit{KB}' \in W(\psi, \mathit{KB})} Mod(\mathit{KB}' \cup \{\varphi\})$ such that $\pi(\mathcal{M}_K)=\mathcal{M}_T$. Clearly, $\mathcal{M}_T$ induces an assignment $\mathcal{M}_X = \mathcal{M}_T \cap \mathit{Var}(\mathit{KB})$, i.e. $\pi^{-1}(\mathcal{M}_T)$. Since, $\mathcal{M}_T$ is minimal, either $d_i$ or $\chi_i$ is satisfied. Since, $d_i$ is more expensive it follows that, a maximal amount of $chi_i$ will be satisfied, i.e. $\mathcal{M}_T \nmodels \neg \psi$, but $(\mathcal{M}_T \cup \{ \chi_j\}) \setminus \{d_j\} \models \neg \psi$. Therefore, $\mathcal{M}_X$ satisfies a maximal amount of $\chi_i$, as their truth value only depends on the values of $x_i$'s. Thus, $\{ \chi_i \mid \forall \chi_i \in \mathit{KB} \; \mathcal{M}_K \models \chi_i \} \in W(\psi, \mathit{KB})$.
%
%
%Thirdly, it is clear that $\pi$ is injective. \\
%
%
%Finally, one can tackle the reduction. Let $\pi$ be the bijection from Observation 2.
%
%$" \Rightarrow "$: Assume that $\mathit{KB} \circ_G \psi \models \varphi $. Meaning that $\forall \mathit{KB}' \in W(\psi, \mathit{KB})$  and $\forall \mathcal{M}_K$ such that $\mathcal{M}_K \models \mathit{KB}' \cup \{\varphi\}$, it holds that $\mathcal{M}_K \models \varphi$. Which is precisely the domain to $\pi$. Since, $\mathcal{M}_T=\pi(\mathcal{M}_K)$ is an extension of $\mathcal{M}_K$ by variables that are not present in $\varphi$ one obtains $\mathcal{M}_T \models \varphi$. As established above $\mathcal{M}_T \in \mathit{MMod}(T)$, thus through the fact that $\pi$ is bijective one obtains $\mathit{MMod}(T)  \models \varphi$.
%
%$" \Leftarrow "$: Assume that $\mathit{MMod}(T)  \models \varphi$. Take an arbitrary model $\mathcal{M}_T \in \mathit{MMod}(T)$, since the truth value of $\varphi$ does not depend on the variables $y_i$ and $z_ij$ in the sentences $T_y$ and $T_z$ respectively, one can safely restrict the model to $\mathcal{M}_X = \mathcal{M}_T \cap \mathit{Var}(\mathit{KB})$ which is incidentally $\pi^{-1}(\mathcal{M}_T)$. Thus, $\pi^{-1}(\mathcal{M}_T) \models \varphi$. With $\mathcal{M}_T$ arbitrary and $\pi$ bijective.
%
%
%
%
%
%
%%
%%
%%Observation X: $\forall \mathit{KB}' \in W(\psi, \mathit{KB})$ and any model $\mathcal{M}$ such that $\mathcal{M} \models  \mathit{KB}'  \cup \{\psi\}$, there exists an extension $\mathcal{M}_T$ such that $\mathcal{M}_T \in \mathit{MMod}(T)$.
%%
%%
%%Observation Y:  $\forall \mathcal{M} \in \mathit{MMod}(T)$ it holds that $\mathcal{M}$
%%
%%
%%
%%$" \Rightarrow "$: 
%%
%%$" \Leftarrow "$: Assume that $\mathit{MMod}(T)  \models \varphi$. Take an arbitrary $\mathit{KB}' \in  W(\psi, \mathit{KB})$ and an arbitrary model $\mathcal{M}$ such that $\mathcal{M} \models \mathit{KB}'  \cup \{\varphi\}$. Extend, $\mathcal{M}$ to $\mathcal{M}_y$ such that $y_i \in \mathcal{M}_y$ if and only if $x_i \notin \mathcal{M}$, i.e. $\sigma_{\mathcal{M}}(x_i)=0$. Since, $\mathcal{M}_y \models T_y $, by Observation  1 $\mathcal{M}_y$ is minimal. Now, by Observation 2,   
%%
%%
%%By Observation 1, one obtains that assigning $x_i \in \mathit{Var}(\mathit{KB})$ to $1$ or to $0$ is irrelevant with respect to minimality. Hence, all models satisfying a $\chi_i$ 
%%
%%
%%
%% but that there exists a model $\mathcal{M}$ and an $\mathit{KB}' \in W(\psi, \mathit{KB})$ such that $\mathcal{M} \models \mathit{KB}' \cup \{\psi\}$ and $\mathcal{M} \models \neg \varphi $. If $\mathcal{M}$ is minimal, one obtains by Observation 2 directly a contradiction.
%%
%%By Observation 2, one knows that for $KB'$ there exists a minimal model $\mathcal{M} \in \mathit{MMod}(T_z \cup \{ \psi\})$ such that $KB'=\{ \chi \mid \forall \chi \in \mathit{KB} \; \mathcal{M} \models \chi\}$. 
%%
%%
%% Clearly, since $\mathit{MMod}(T_y) = \mathit{Mod}(T_y)$ and $T_y$ contains all variables in $\mathit{KB} \cup \{\varphi\}$, $\mathit{MMod}(T_y)$ is actually the set of all possible interpretations of $\mathit{KB} \cup \{\varphi\}$. For any $\mathcal{M} \in  \mathit{MMod}(T_y)$ let $\overline{\mathcal{M}}$ be an arbitrary extension such that $\overline{\mathcal{M}} \models T$.
%
%%
%%
%%
%%$A_\mathcal{M} \subset  \{\neg x \mid \forall x \in \mathit{Atom}(T)\}$ 
%%
%%$" \Rightarrow "$: Assume that $\mathit{EGCWA}(T) \models \varphi$. Hence, $\forall \mathcal{M} \in \mathit{Mod}(\mathit{EGCWA}(T)) \; \mathcal{M} \models \varphi$, which given the theorem in the lecture slides, is equivalent to $\forall \mathcal{M} \in \mathit{MMod}(T) \; \mathcal{M} \models \varphi$. Since, $\forall \mathcal{M} \in \mathit{MMod}(T)$ it must be that $\mathcal{M}  \subseteq \mathcal{M} ' \implies (\sigma_{\mathcal{M} }(x)=1 \Rightarrow \sigma_{\mathcal{M} '}(x)=1 )$, it follows that $\forall \mathcal{M} \in \mathit{MMod}(T)$ it must be the case that $\mathcal{M}  \subseteq \mathcal{M} ' \implies (\sigma_{\mathcal{M}' }(x)=0 \Rightarrow \sigma_{\mathcal{M}}(x)=0 )$. Hence, for any $\mathcal{M} \in \mathit{MMod}(T)$ the set $A_{\mathcal{M}}:=\{ \neg x \mid \forall x \in \mathit{Atom}(T)\;  \mathcal{M} \models \neg x \}$ is maximal and distinguishes $\mathcal{M}$ among all models in $\mathit{MMod}(T)$. To be more precise the set $A_{\mathcal{M}}$ can only be satisfied by models that assign more variables to $0$. However, since $\mathcal{M}$ is a minimal interpretation that still serves as a model for $T$, setting any additional variable to $0$ would lead to $\mathcal{M} \nmodels T_{\land}$. Therefore, any maximal subset $A_{\mathcal{M}} \subset \{\neg x \mid \forall x \in \mathit{Atom}(T)\}$ 
%%
%%Now, $\mathcal{M}$ models $T$, it is clearly the case that $\mathcal{M} \models T_{\land}$.
%%
%%
%%consider a subset $S \subset \{ \neg x \mid \forall x \in \mathit{Atom}(T) \}$ such that the model $\mathcal{M} \models T_{\land}$ satisfies 
%%
%
%\newpage
%
%%######################################################################
%
%\item (10) The problem {\bf ODDSAT} is the instance of the problem on
%  slide 62 for $k=1$, i.e.,
%
%\smallskip
%
%INSTANCE: SAT instances  $E_1$, \ldots, $E_n$,  $n\geq 1$.
%
%\smallskip
%
%QUESTION: Is the number of satisfiable formulas among $E_1$, \ldots
%,$E_n$  (i.e., $|\,\{ E_i \mid  E_i$ is satisfiable, $1\leq i \leq n\}\,|$)
%an odd number?  
%
%\begin{enumerate}[(a)]
%\item Show that  {\bf ODDSAT} $\leq^p_m$ {\bf EVENSAT}, which has
%the same instances but the question is negated (i.e., the number of
%satisfiable formulas $E_i$ is even)
%
%\item Show that {\bf EVENSAT} $\leq^p_m$ {\bf CF}$_D$ by providing a
%polynomial-time transformation; without
%loss of generality, you may assume that satisfiability of $E_i$ implies satisfiability of $E_{i+1}$, for 
%all $1\leq i < n$.
%\end{enumerate}
%
%Bonus: show that the ``without loss of generality'' assumption in
%item (b) holds.
%
%
%\begin{enumerate}[(a)]
%\item Show that  {\bf ODDSAT} $\leq^p_m$ {\bf EVENSAT}, which has
%the same instances but the question is negated (i.e., the number of
%satisfiable formulas $E_i$ is even) \\
%
%
%
%Consider the following transformation $\tau$ 
%\begin{equation*}
%\tau(E_1, \dots, E_k) = E_1, \dots, E_k, (p \lor \neg p)
%\end{equation*}
%where $p$ is a fresh propositional variable.
%
%$"\Rightarrow"$: Assume that an odd number, let it be $n$, of formulas among $E_1, \dots, E_k$ is satisfied. Since, $(p \lor \neg p)$ is a tautology, it follows that $n+1$ is even. Hence, among $\tau(E_1, \dots, E_k)$ an even number of formulas is satisfied. Therefore, one can conclude that $\tau(E_1, \dots, E_k)$ is an accepted instance of \textbf{EVENSAT}.
%
%$"\Leftarrow"$: Assume that an even number, let it be $n$, of formulas among $\tau(E_1, \dots, E_k)$ is satisfied. Since, $(p \lor \neg p)$ is a tautology, there is at least one formula satisfied. Hence, $n>0$, and due to the fact that $n$ even it follows that $n>1$. Meaning among $E_1, \dots, E_k$ there is at least one formula satisfied. With the corner case covered, the general argument is that since $n$ one obtains through $(p \lor \neg p)$ being a tautology, that $n=m+1$ with $m$ odd. Therefore, one can conclude that an odd number of formulas among $E_1, \dots, E_k$ is satisfied, i.e. they are an accepting instance of \textbf{ODDSAT}. \\
%
%
%
%\item Show that {\bf EVENSAT} $\leq^p_m$ {\bf CF}$_D$ by providing a
%polynomial-time transformation; without
%loss of generality, you may assume that satisfiability of $E_i$ implies satisfiability of $E_{i+1}$, for 
%all $1\leq i < n$.
%
%
%
%Firstly, with out loss of generality, assume that $k$ is even. This can be done since one can simply add an unsatisfiable formula at the beginning of all formulas and shift the index, e.g. $E_1, \dots, E_k$ with $k$ odd, to $ E_1', \dots, E_{k+1}'= (p \land \neg p),  E_1, \dots, E_k$.
%
%Secondly, without loss of generality, assume that the variables of each formula are pairwise disjoint, i.e. $\forall i, j \in \{1, \dots, k\} \; i \neq j \Rightarrow \mathit{Var}(E_i) \cap \mathit{Var}(E_j)=\emptyset$.
%
%
%
%Consider the following transformation $\tau(E_1, \dots, E_k)=(T, \psi, \varphi)$ where $\tau$ is an input instance for $T \circ_D \psi \models \varphi$ and where 
%\begin{equation*}
%\begin{split}
%T &:= \{c_1, \dots, c_k\} \\
%\psi &:= \bigwedge_{i \in \{1, \dots, k\}} c_i \to E_i \\
%\varphi &:=   c_1 \lor \big(\bigvee_{i \in \{1, \dots , \frac{k}{2}-1\}} (\neg c_{2i}   \land  c_{2i+1} )\big)   \lor \neg c_k 
%\end{split}
%\end{equation*}
%Firstly, this transformation only increases the input in a linear manner with respect to the number of clauses. Thus this transformation can be done in polynomial time.
%% \land \bigwedge_{i \in \{1, \dots, k-1\}} (c_i \to c_{i+1})
%
%$"\Rightarrow"$: Assume that an even number, let it be $n$, of formulas among $E_1, \dots, E_k$ is satisfied. \emph{Case 1}, all formulas are satisfied. As established in the lecture all models in $\mathit{Mod}(T \circ_D \psi)$ satisfy the maximum number of $c_i$'s. In this case all of them must be satisfied.
%% With all formulas satisfied, $c_1$ and all $i<k$, $(c_i \to c_{i+1})$ are satisfied.
% \emph{Case 2}, no formula is satisfied. In this case no $c_i$ is satisfied, i.e. the only model of $\psi$ is the one that is empty and this it is the only model of $T \circ_D \psi$, thus $\neg c_k$ is satisfied.
%% , and all $(c_i \to c_{i+1})$ for $i<k$ hold vacuously.
%\emph{Otherwise}, there exists at least one formula that is not satisfied and at least one that is. Hence, given the input restriction, there exists an $m$ such that $E_{m}$ is not satisfied and $E_{m+1}$ is satisfied. 
%Since, $\mathcal{M} \in \mathit{Mod}(T \circ_D \psi)$ means that $\mathcal{M}$ satisfies a maximal amount of $E_{i}$'s, one can conclude that no further $c_i$ can be satisfied. Hence, the number of $c_i$ satisfied is maximal, therefore even. Moreover, no model in  $ \mathit{Mod}(T \circ_D \psi)$ can satisfy any smaller then $m+1$, as otherwise the input restriction is violated, this forces that in all model in $ \mathit{Mod}(T \circ_D \psi)$ it must be the case that for every $m < i \leq k$ $c_i$ is satisfied. Meaning that $m$ is the same in all models and must be even, i.e. $m = 2j$.  Thus  $\neg c_{2i}   \land  c_{2i+1} $ is satisfied in all models. 
%%Moreover, since for every $m < i \leq k$ $c_i$ is satisfied by assumption, it follows that all $i<k$, $(c_i \to c_{i+1})$ are satisfied in all models as well. 
%Thus one obtains $T \circ_D \psi \models \varphi$.
%
%
%
%$"\Leftarrow"$:  Assume that an even number, let it be $n$, of formulas among $E_1, \dots, E_k$ is satisfied. Given the assumptions made above, neither the case where all formulas nor the case were no formula is satisfied apply have to be considered. Hence, there exists at least one formula that is not satisfied and at least one that is. Hence, given the input restriction, there exists an $m$ such that $E_{m}$ is not satisfied and $E_{m+1}$ is satisfied. Clearly, this $m$ is odd, i.e. $m = 2j+1$ for some $j$. Moreover, given the input restriction it is known that for all $i \leq m$ $E_i$ is unsatisfiable and that for all $m < i \leq k$ $E_i$ is satisfiable. Since, every model $\mathit{Mod}(T \circ_D \psi)$ maximises the number of $c_i$'s, it follows that for all $i \leq m$ $c_i$ evaluates to $0$ and that for all $m < i \leq k$ $c_i$ evaluates to $1$ in every model. Hence, in every model of  $\mathit{Mod}(T \circ_D \psi)$, the transition from unsatisfied formulas to satisfied formulas occurs on $c_{2j+1}$ and $c_{2 \cdot (j+1)}$. Hence, no model can satisfy $  c_1 \lor \big(\bigvee_{i \in \{1, \dots , \frac{k}{2}-1\}} (\neg c_{2i}   \land  c_{2i+1} )\big)   \lor \neg c_k $. Therefore, $T \circ_D \psi \nmodels \varphi$.
%
%
%\item Bonus: show that the ``without loss of generality'' assumption in
%item (b) holds.
%
%Here unfortunately an somewhat indirect answer. Meaning that by giving an algorithm that establishes $\Delta^P_2[O(log)]$-membership of the unrestricted case, then using the fact that the restricted case is $\Delta^P_2[O(log)]$-complete to show completeness of the general case and thereby establish that those problems can be used interchangeably. Hence, consider the following algorithm
%
%\texttt{
%\begin{tabbing}
%EVE\=NSAT($(E_1,\dots ,E_k)$): \\
%\> $Q:= (\lambda x_1 \dots \lambda x_k (\text{SAT}(x_i))_{i \in \{1, \dots, k\}})$   // (1) \\
%\> $Q_a := Q\; (E_1,\dots E_k)$ // (2) \\
%\> if \=$\sum_{a_i \in Q_a} a_i$ is even: \\
%\>\> return True \\
%\> else: \\
%\>\> return False
%\end{tabbing}}
%
%In step (1) $k$ independent queries to a \textbf{SAT}-oracle, returning $1$ if the instance is satisfiable and $0$ otherwise, are set up.
%Then, those prepared queries are executed in parallel on the formulas $ (E_1,\dots ,E_k)$.  With a linear amount of parallel oracle calls and with all remaining steps being done in linear time as well, this algorithm establishes  $\mathbf{P_{||}^{NP}}$-membership. However, since this class coincides with the class $\Delta^P_2[O(log)]$ the membership can be transferred. Now knowing that the restricted case is $\Delta^P_2[O(log)]$-complete, completeness of the general case follows in suit. Hence, there must exist a reduction of the form $\textbf{EVENSAT}_G \leq^p_m \textbf{EVENSAT}_R$, i.e. general to restricted case. Hence, the reduction in the previous exercise suffices.
%\end{enumerate}
%
%
%%######################################################################
%
%\item{(5)} Show that the problem {\bf CF}$_D$ is 
%\begin{itemize}
%      \item \NP-hard, 
%      \item \coNP-hard, 
%
%\end{itemize}
%by suitable reductions from  {\bf SAT} respectively {\bf UNSAT}.
%\end{enumerate}

 \end{document}



%%% Local Variables:
%%% fill-column: 72
%%% TeX-PDF-mode: t
%%% TeX-debug-bad-boxes: t
%%% TeX-master: t
%%% TeX-parse-self: t
%%% TeX-auto-save: t
%%% reftex-plug-into-AUCTeX: t
%%% End:



